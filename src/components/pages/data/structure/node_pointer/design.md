# Node + Pointer 数据结构演示器设计文档

## 1. 项目愿景 (Vision)
构建一个结合 **“可视化直觉”** 与 **“硬核性能基准”** 的数据结构实验室。不仅展示数据结构“长什么样”，更重要的是让用户**在实际痛点中见证数据结构的“自然生长”**。

用户不需要编写代码，而是作为“架构师”面临具体的业务挑战（如“设计一个即时日志系统”或“构建亿级用户索引”）。通过对比不同数据结构在同一场景下的表现（速度、内存消耗、I/O 次数），直观地感受到：
*   为什么数组扩容那么痛？ -> 链表的诞生。
*   为什么链表查数据那么慢？ -> BST 的诞生。
*   为什么顺序插入会让 BST 变废？ -> 平衡树的诞生。
*   为什么内存里跑得快的树到了磁盘上就不行了？ -> B+ 树的诞生。

我们不是在教教科书，而是在**重演计算机科学的历史选择**。

## 2. 核心挑战与架构决策

### 2.1 存储后端抽象 (Storage Abstraction)
为了同时满足“快速开发逻辑”和“展示底层特性（如 B-Tree 的局部性优势）”，我们将采用**存储后端分离**的设计。

系统应支持两种模式：
1.  **Reference Mode (JS Objects)**
    *   **实现原理**: 利用 JS 原生对象引用 (`node.left`, `node.next`)。
    *   **优势**: 开发简单，GC 自动处理，调试方便。
    *   **劣势**: 无法模拟内存碎片、无法控制内存布局、无法体现 B-Tree 的缓存友好性。
    *   **用途**: 早期逻辑验证、纯逻辑可视化、教学演示。

2.  **Linear Memory Mode (TypedArray Simulation)**
    *   **实现原理**: 使用一个巨大的 `ArrayBuffer`，自己实现简易的 `Allocator` (malloc/free)。指针本质是数组索引（`ptr: number`）。
    *   **优势**: 真实模拟 C/C++ 内存环境，能够展示**数据局部性 (Locality)**、页大小 (Page Size) 对性能的影响。这是证明 B+ 树优于二叉树的关键。
    *   **劣势**: 复杂度高（需处理序列化、空闲链表管理）。
    *   **用途**: 高级性能测试、模拟磁盘/内存块操作。

### 2.2 核心接口定义 (Core Interfaces)

```typescript
// 指针类型：在 Ref 模式下是对象，在 Memory 模式下是 number (index)
type Pointer = object | number;

interface MemoryBackend<T> {
  // 分配节点空间
  malloc(size: number): Pointer; 
  // 释放节点
  free(ptr: Pointer): void;
  // 读取/写入数据
  read(ptr: Pointer, offset: number): any;
  write(ptr: Pointer, offset: number, value: any): void;
  // 获取可视化快照（用于渲染）
  getSnapshot(): GraphSnapshot;
}
```

## 3. 演化史章节编排 (Evolutionary Chapters)

### 序章：定长的黄昏 (The Twilight of Fixed Length)
*   **时代背景**: 1950s 前，硬件资源极度匮乏。
*   **核心结构**: **Fixed Array (定长数组)**。
*   **痛点演示**: 
    *   **"僵硬的容器"**: 申请了 10 个空间，来第 11 个数据时，必须重新开辟 20 个空间并全量复制。
    *   **内存碎片**: 展示一堆不同长度的数组把内存切得支离破碎。

### Chapter 1: 指针的觉醒 (The Awakening of Pointers)
*   **时代背景**: 1955-1960 (IPL 语言)。为了解决动态内存分配问题，Allen Newell 等人引入了“链”的概念。
*   **演化脉络**:
    *   **Singly Linked List**: 只需要一个 `next` 指针，内存这一刻“活”了。
    *   **Doubly Linked List**: 增加 `prev`，为了 O(1) 删除当前节点（需要知道前驱）。
    *   **Circular Linked List**: 解决循环访问需求（如时间片轮转调度）。
    *   **Linked Stack/Queue**: 限制操作端口的特殊链表。
*   **互动场景**: **"多任务调度器"**
    *   任务：模拟操作系统进程调度，频繁插入/杀死进程。
    *   对比：数组移动元素的 O(N) 卡顿 vs 链表指针操作的 O(1) 流畅。

### Chapter 2: 分叉的智慧与平衡的代价 (Branching & Balance)
*   **时代背景**: 1960s-1970s。数据量增大，链表 O(N) 查找太慢。
*   **演化脉络**:
    *   **BST (1960)**: 从单链表演化而来，以此换取 O(log N) 查找。但遇到有序输入会退化。
    *   **AVL Tree (1962)**: 第一次引入“平衡因子”，通过严格旋转保持绝对平衡。适用于读多写少。
    *   **2-3 Tree (1970)**: John Hopcroft 提出。演化自：B 树的特例（阶数为 3），提供比平衡二叉树更简单的平衡逻辑。
    *   **2-3-4 Tree (1972)**: Rudolf Bayer 提出。演化自：2-3 树，支持更高阶的平衡节点。
    *   **Red-Black Tree (1978)**: 2-3-4 树的二叉形态。通过颜色变换和少量旋转，在插入速度和查找速度间取得完美折中。成为工业界标准（Linux, Java HashMap）。
*   **互动场景**: **"防火墙规则匹配"**
    *   任务：匹配大量 IP 规则。
    *   挑战：恶意攻击者构造特定顺序 IP 插入，观察 BST 沦陷，而红黑树稳如泰山。

### Chapter 3: 概率与随机的赌局 (The Gamble of Probability)
*   **时代背景**: 1980s。红黑树实现太复杂，程序员们开始思考：能否用随机性换取代码的简洁？
*   **演化脉络**:
    *   **Splay Tree (1985)**: 不需要存平衡信息，每次访问都把节点旋到根部。利用“局部性原理”（最近访问的大概率再次访问）。
    *   **Skip List (1989)**: 链表加了“多级跳板”。用硬币投掷决定层高，实现了 O(log N) 且易于并发实现（Redis 的选择）。
    *   **Treap (1989)**: Tree + Heap。随机优先级维持平衡。
*   **互动场景**: **"热点缓存系统"**
    *   任务：访问符合 80/20 法则的数据（少数数据被频繁访问）。
    *   对比：Splay Tree 自动将热点数据维持在树根，访问速度极快；而红黑树对所有节点一视同仁。

### Chapter 4: 块存储的霸权 (The Hegemony of Block Storage)
*   **时代背景**: 1970s-1990s。磁盘时代，I/O 是最大瓶颈。
*   **演化脉络**:
    *   **B-Tree (1970)**: Rudolf Bayer 提出。演化自：BST，将每个节点改为能存多个键值并有多个分支，专门解决磁盘/大规模数据存储。
    *   **B+ Tree (1970s)**: 数据只在叶子，叶子连成链表。扫库神技。这是链表与树的完美结合。
    *   **LSM Tree (1996)**: O'Neil 提出。将随机写转化为顺序写。现代 NoSQL (RocksDB) 基石。
*   **可视化重点 (Vis Focus)**:
    *   **Memory View (物理视图)**: 展示二叉树节点在内存/磁盘条带上是散乱分布的（Cache Miss 高）。
    *   **B+ 树分裂**: 展示一个节点塞满后，裂变成两个，并向上冒泡的过程。
    *   **B+ 树范围查询**: 展示叶子节点像链表一样串连，一次 I/O 拉取一整块数据。
*   **互动场景**: **"亿级数据库索引"**
    *   **必须启用 Linear Memory Mode (Page Simulation)**
    *   任务：模拟数据库查询 `SELECT * FROM table WHERE id BETWEEN 1000 AND 2000`。
    *   指标：统计 **"Page Faults" (模拟磁盘读取次数)**。
    *   结果：二叉树读取 500 次磁盘，B+ 树读取 3 次磁盘。这是终极的性能杀手锏。

### Chapter 5: 空间与维度的诅咒 (Curse of Dimensionality)
*   **时代背景**: 1970s-1980s。地理信息系统 (GIS) 兴起。
*   **演化脉络**:
    *   **Quadtree (1974)**: 二维空间的二分查找。
    *   **K-d Tree (1975)**: K 维空间的二叉树。
    *   **R-Tree (1984)**: B 树在多维空间的推广，处理矩形重叠。
*   **互动场景**: **"外卖小哥在哪里"**
    *   任务：查找“我附近的 5 个骑手”。
    *   演示：普通 BST 无法处理 (x, y) 两个维度的临近，R-Tree 快速圈定范围。

### Chapter 6: 字符串的特种兵 (Special Forces of Strings)
*   **时代背景**: 1959-1990s。文本处理与搜索引擎。
*   **演化脉络**:
    *   **Trie (1959)**: René de la Briandais 提出。空间换时间，利用公共前缀。
    *   **Patricia Trie (1968)**: Donald Morrison 提出。路径压缩，节省空间。
    *   **Suffix Tree (1990s)**: 解决复杂的子串匹配问题。
*   **互动场景**: **"IDE 智能补全"**
    *   任务：输入代码前缀提示 API。
    *   对比：遍历所有字符串 vs Trie 树瞬间定位前缀。
*   **Bonus Structure**: **Hash Map (拉链法)**
    *   场景: **"缓存系统"**。O(1) 的极致速度，但当哈希冲突严重时（模拟恶意攻击），退化成链表。

## 4. 技术栈与实施计划
*   **UI**: React + Canvas (PixiJS/Konva) 用于高性能渲染节点。
*   **Core**: TypeScript, 手写内存分配器 (Slab Allocator 简化版)。
*   **测试**: Vitest 用于验证数据结构逻辑正确性。
