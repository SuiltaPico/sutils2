## 1. 业务编排与规则映射
本质: 将现实世界的规则（往往是琐碎、易变、非结构化的）翻译成计算机的 if-else 和 CRUD。
复杂度来源: 广度与易变性。难点不在于单个逻辑的深度，而在于逻辑之间的耦合、状态机的流转以及需求变更的频率。
典型场景：
- 电商下单流程（库存扣减、优惠券计算、支付状态流转）。
- 审批流系统（A批完B批，如果金额>X则C批）。
- CMS 内容管理（发布、草稿、权限控制）。

Demo
```
// ==========================================
// 1. 标准库扩展 (Prelude & Utils)
// ==========================================

// 结果类型构造
let Ok  = (v) { { ok: True,  val: v,    err: None } }
let Err = (e) { { ok: False, val: None, err: e } }

// 列表操作 (利用尾值返回)
let Sum = (list, f) {
  If{ list.length == #0, 
    0, 
    f{ List.Head{list} } + Sum{ List.Tail{list}, f } 
  }
}

let Any = (list, pred) {
  If{ list.length == #0, 
    False, 
    If{ pred{ List.Head{list} }, True, Any{ List.Tail{list}, pred } }
  }
}

// ==========================================
// 2. 领域模型定义
// ==========================================

let Category = {
  Physical: Nominal.Create {},
  Virtual:  Nominal.Create {}
}

let OrderStatus = {
  Created: Nominal.Create {}, // 直接用 Exact Number 或名义符号
  Paid:    Nominal.Create {},
  Failed:  Nominal.Create {}
}

// ==========================================
// 3. 主业务逻辑：下单流程
// ==========================================

let handle_order = (userId, items, couponCode, payMethod) {

  // --- 1. 用户合法性校验 (Guard Clauses) ---
  let user = DB.GetUser{ userId }
  
  // 若找不到用户或用户未激活，立即早期返回
  If{ user == None,           Return{ Err{"UserNotFound"} } }
  If{ user.is_active != True, Return{ Err{"UserInactive"} } }

  // --- 2. 费用计算与配送校验 ---
  let subtotal = Sum{ items, (it) { it.price * it.qty } }
  
  let hasPhysical = Any{ items, (it) { it.category == Category.Physical } }
  If{ hasPhysical && user.address == None, 
    Return{ Err{"MissingShippingAddress"} } 
  }

  // --- 3. 资金与库存预检 ---
  // 利用 Ordinal 子类型简化比较：balance < subtotal
  If{ user.balance < subtotal, Return{ Err{"InsufficientBalance"} } }

  // --- 4. 营销逻辑 ---
  let pricing = Coupon.Apply{ subtotal, couponCode }
  If{ pricing.error != None, Return{ Err{pricing.error} } }
  let payable = pricing.payable

  // --- 5. 资源锁定与订单创建 ---
  let reserved = Inventory.ReserveAll{ items }
  If{ !reserved, Return{ Err{"OutOfStock"} } }

  let order = DB.CreateOrder{ userId, items, payable }
  DB.UpdateOrderStatus{ order.id, OrderStatus.Created }

  // --- 6. 最终支付分支 (尾值作为整个函数的返回值) ---
  let payRes = Pay.Charge{ order.id, payMethod, payable }
  
  If{ payRes.ok, (
    // 支付成功路径
    DB.UpdateOrderStatus{ order.id, OrderStatus.Paid }
    Notify.SendEmail{ user.email, "Success", order.id }
    Console.Log{ "Order Success:", order.id }
    
    Ok{ orderId: order.id } // 块的尾值
  ),(
    // 支付失败路径
    Inventory.ReleaseAll{ items }
    DB.UpdateOrderStatus{ order.id, OrderStatus.Failed }
    Notify.SendEmail{ user.email, "Failed", payRes.error }
    
    Err{ payRes.error } // 块的尾值
  )}
}
```

## 2. 计算密集与算法核心
本质： 数学推导与确定性逻辑的深度实现。追求时间复杂度和空间复杂度的极限。
复杂度来源： 深度与正确性。逻辑链条极长，稍微错一点全盘皆输，通常涉及复杂的数据结构（树、图）。
典型场景：
- 编译器前端/后端： 词法分析、语法树构建、寄存器分配。
- 图形渲染引擎： 光线追踪算法、矩阵变换、物理碰撞检测。
- 调度器： 操作系统进程调度、Go 语言 GMP 模型调度。
- 音视频编解码： FFmpeg 内部的压缩算法。

Demo (编译器解析器片段 - 递归下降法)
```
// ==========================================
// 1. AST 节点构造工厂
// ==========================================
let AST = {
  Binary: (op, left, right) { { __nominal__: Nominal.Create{}, op: op, left: left, right: right } },
  Lit:    (val) { { __nominal__: Nominal.Create{}, val: val } }
}

// ==========================================
// 2. 解析逻辑 (使用 Cond 表达多分支)
// ==========================================

// 解析基础表达式 (数字或括号)
let parse_primary = (tokens) {
  let head = List.Head{tokens}
  let rest = List.Tail{tokens}

  Cond{
    // 分支 1: 处理数字字面量
    Branch{ head.type == "Number", 
      { node: AST.Lit{head.val}, next: rest } 
    },

    // 分支 2: 处理括号表达式 (递归调用)
    Branch{ head.type == "LParen", (
      let inner = parse_expr{rest}
      let close = List.Head{inner.next}
      
      Cond{
        Branch{ close.type == "RParen", 
          { node: inner.node, next: List.Tail{inner.next} } 
        },
        Else{ Error{"Expected matching 'RParen'"} }
      }
    )},

    // 兜底分支: 语法错误
    Else{ Error{"Unexpected token: " + head.type} }
  }
}

// 解析乘法优先级 (利用 Cond 处理循环终止)
let parse_mult = (tokens) {
  let lhs = parse_primary{tokens}
  
  let _loop = (cur_lhs, cur_tokens) {
    let op = List.Head{cur_tokens}
    
    Cond{
      Branch{ op.type == "Star" || op.type == "Slash", (
        let rhs = parse_primary{ List.Tail{cur_tokens} }
        let new_node = AST.Binary{op.val, cur_lhs, rhs.node}
        _loop{new_node, rhs.next} // 尾递归
      )},
      // 没有更多乘除符，返回当前节点
      Else{ { node: cur_lhs, next: cur_tokens } }
    }
  }

  _loop{lhs.node, lhs.next}
}

// 解析加法优先级 (最高层入口)
let parse_expr = (tokens) {
  let lhs = parse_mult{tokens}
  
  let _loop = (cur_lhs, cur_tokens) {
    let op = List.Head{cur_tokens}

    Cond{
      Branch{ op.type == "Plus" || op.type == "Minus", (
        let rhs = parse_mult{ List.Tail{cur_tokens} }
        let new_node = AST.Binary{op.val, cur_lhs, rhs.node}
        _loop{new_node, rhs.next}
      )},
      Else{ { node: cur_lhs, next: cur_tokens } }
    }
  }

  _loop{lhs.node, lhs.next}
}

// ==========================================
// 3. 执行测试
// ==========================================
// 表达式: "1 + 2 * 3"
let tokens = [
  {type: "Number", val: 1}, 
  {type: "Plus",   val: "+"}, 
  {type: "Number", val: 2}, 
  {type: "Star",   val: "*"}, 
  {type: "Number", val: 3}
]

let result = parse_expr{tokens}
// result.node 将构造出深度的 AST 树结构
```