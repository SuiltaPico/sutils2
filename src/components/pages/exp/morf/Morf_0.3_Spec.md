# Morf 0.3 Language Specification

## 0. 规范性关键字与术语

### 0.1 规范性关键字

本规范使用下列关键字表达规范性要求：

- **必须（MUST）/不得（MUST NOT）**：绝对要求。
- **应当（SHOULD）/不应当（SHOULD NOT）**：强烈建议；仅当存在充分理由时才允许偏离。
- **可以（MAY）**：可选特性或实现自由度。

除非明确标注为“实现建议/注释/示例”，否则本规范中的陈述均为规范性要求。

### 0.2 术语与记号

- **构体（Morph）**：由键到值的不可变映射；在 Morf 中**值与类型统一**，因此构体既可以作为运行时值，也可以作为静态类型项参与计算。
- **键（Key）**：任何可作为映射索引的值（字符串、符号、数字或其他构体）。
- **值层（Value layer）**：程序求值后的运行时实体集合。
- **类型逻辑层（Type-logic layer）**：用于静态判定与归约的逻辑项层（`<:`、`|`、`&`、`~` 等）。
- **语义模型层（Semantic model layer）**：用于解释类型含义的集合论模型；仅用于说明，不要求作为运行时结构实现。

记号约定：

- **子类型**：`A <: B` 表示 $A$ 是 $B$ 的子类型。
- **定义等价**：`A ≡ B` 表示二者在类型逻辑层归约后为同一规范形（见 2.1.2）。
- **运行时相等**：`A == B` 表示运行时值相等（实现必须定义为可判定关系）。

## 1. 概述

本规范定义 Morf 0.3 语言的语法与静态/动态语义。Morf 是一门实验性语言，其核心统一构造是“构体”；类型系统以结构化子类型与类型逻辑正规形为基础，并通过名义属性引入可稳定标识的名义层。

### 1.1 设计原则与分层模型

为保证系统在处理极端代数结构（如嵌套集合、递归构体）时的一致性，Morf 遵循以下三层语义模型：

1.  **值层**：程序运行时的实体集合。包括构体实例、`None`、数字、字符串、序列（`Seq`）以及可变槽位（`Slot`）。
2.  **类型逻辑层**：用于静态判定与子类型计算的逻辑项（`<:`、`|`、`&`、`~`）。该层通过**规范化**归约为规范形，以保证等价与子类型判定的稳定性。
3.  **语义模型层**：用于解释类型的数学集合模型（如 `~T = Uni - T`）。这仅作为语义证明的参考，不作为值层的数据结构。

### 1.2 核心理念

Morf 的设计围绕着“统一”与“精确”展开，旨在打破传统编程语言中人为划定的边界：

1.  **万物皆构体**：取消对象、模块、接口、参数列表等概念的语法隔阂，将其统一抽象为“构体”。这种统一性使得宏、元编程和结构化操作变得极度一致。
2.  **值与类型统一**：消除“值空间”与“类型空间”的二元对立。类型仅仅是值的集合，值则是单例类型。这赋予了类型系统直接操作值的能力（依赖类型），同时也让运行时代码拥有了类型的表达力。
3.  **逻辑完备的结构化类型**：建立在集合论基础上的类型系统，支持并集、交集与补集。类型检查即集合包含关系的判定，提供了极高的表达密度与精确性。
4.  **默认不可变与受控副作用**：拥抱函数式编程的不可变数据流，同时通过显式的 `mut` 槽位和 Effect 系统，以受控的方式引入命令式编程的便利与性能。


---

## 2. 类型系统核心

Morf 的类型全集由以下基元和复合结构组成。

### 2.1 形式化约定与等价性

本规范使用以下约定来描述类型系统与计算规则。

#### 2.1.1 记号约定

- **子类型关系**：`A <: B` 表示 A 是 B 的子类型。
- **定义等价**：`A ≡ B` 表示 A 与 B 在类型系统中是同一个逻辑项。
- **运行时相等**：`A == B` 表示在运行时两者的值相等。
- **运算记号**：`A | B`（析取）、`A & B`（合取）、`~A`（补集）。

#### 2.1.2 规范形

为保证子类型判定与等价检查的稳定性，类型项在逻辑层会通过一组重写规则归约为**规范形**。
所有的逻辑运算（如 `DiSet` 的扁平化）都基于定义等价 `≡`。

### 2.2 子类型系统

Morf 遵循标准的结构化子类型规则。

#### 2.2.1 定义

##### 子类型
对于类型 $A$ 和 $B$，若 $A$ 是 $B$ 的子类型（记作 $A <: B$），则凡是需要 $B$ 的地方都可以安全地使用 $A$。

#### 2.2.2 构体子类型规则
在 Morf 中，构体在类型逻辑层被视为“对所有键均有定义的总映射”：当某键未被显式约束时，其值类型默认为 `Uni`（见 2.3.1）。因此传统结构子类型的“宽度/深度”规则可统一为逐键子类型。

**定义（键投影）**：对任意构体类型项 `T` 与任意键 `k`，`T[k]` 表示 `T` 对键 `k` 的值类型约束。实现必须按以下优先级计算 `T[k]`：

1. **具体键约束优先**：若 `T` 含有对某个具体键 `k` 的约束条目（字面量键或计算键，见 3.5.1/3.5.2），则 `T[k]` 必须等价于该条目的值类型。
2. **范围键其次**：否则，若 `T` 含有一个或多个范围键约束 `{ [...K_i]: V_i }`（见 3.5.3），且满足 `k <: K_i`，则 `T[k]` 必须取这些候选约束在“后来者覆盖”规则下生效后的值类型。
3. **默认值**：否则 `T[k] ≡ Uni`。即，未被约束的键默认为全集 `Uni`，而非空值 `None`。

> **边界定义（开放性）**：
> 根据上述规则 3，类型 `{ x: Number }` 在语义上等价于 `{ x: Number, [...]: Uni }`。
> 这意味着类型定义默认是**开放的（Open）**：它允许实例包含未声明的额外属性。
> 若要定义**封闭类型（Closed Type）**（即禁止额外属性），必须显式使用范围键约束其他键为 `None`，例如：`{ x: Number, [...]: None }`。

> 注（非规范性）：上述定义使得 `T` 可用有限条目描述一个“无限映射”，从而保持可实现性。

**规则（构体子类型）**：对任意构体类型项 `A` 与 `B`，

$$ A <: B \ \text{当且仅当}\ \forall k,\ A[k] <: B[k] $$

其中量化域为“所有可作为键的值”（值层宇宙）。实现可以采用等价的、保守的有限检查算法，但不得把满足上式的 `A <: B` 误判为假。

> 注（非规范性）：直观上，约束越多、约束越强，类型越窄。

### 2.3 核心基元

#### 2.3.1 构体（Morph）
构体是键值对的不可变集合。

在 Morf 中，所有值都以“构体”统一表示；因此键和值在语义上都属于值层实体（可包含数字、字符串、符号等作为键/值）。

$$
\text{Morph} = \{ k_1: v_1, \ k_2: v_2, \ \dots\}
$$

* **默认属性**：在未加约束的情况下，任何键的值默认为 `Uni`。

#### 2.3.2 顶空间（Uni）
表示“无具体约束”的构体。它是构体的**顶类型**。在 Morf 中可以使用 `{}` 表达。

* **子类型关系**：顶空间是所有类型的父类型。
$$
\text{Uni} =  \{ k: \text{Uni} \mid \forall k \}
$$
* **键定义**：其所有键都是顶空间。
* **构成**: 
$$
\text{Uni} = \text{Proof} \cup \text{None}
$$

在下文，我们称其为 Uni。

#### 2.3.3 底空间（Never）
表示**不可居住（uninhabited）**的类型（语义模型层的空集合）。它是构体类型体系中的**底类型**，常用于表示逻辑矛盾或不可满足的约束。

$$
\text{Never} \equiv DiSet\{ \} \equiv \sim \text{Uni}
$$


* **子类型关系**：底空间是所有类型的子类型。
* **键定义**：其所有键都是底空间。

在下文，我们称其为 Never。


#### 2.3.4 空值（None）
表示“值的缺失”或“无效信息”，但它本身是一个合法的、存在于 Uni 中的值。

* **定义**:
$$ \text{None} = \{ k: \text{None} \mid \forall k \} $$
* **语法表达**: 在语言层面可表达为 `None = { [...]: None }`。
* **传染性**：由于其递归定义，对 None 进行任意深度的属性访问，结果永远是 None。这使得 Optional Chaining 成为类型的内禀属性，而非语法糖。
* **特性**: 
$$
\text{None} = \sim\text{Proof}
$$

在下文，我们称其为 None。

#### 2.3.5 实存（Proof）
表示“有效信息”的集合。它是顶空间中除去 None 之外的所有部分。
$$ \text{Proof} = \sim \text{None} $$
* **定义**：任意值 \(v\)，若 \(v \not\equiv None\)，则 \(v \in Proof\)。

在下文，我们称其为 Proof。


#### 2.3.6 构体的补集
$\sim \text{Type}$ 表达 Uni 中所有不属于 $\text{Type}$ 的构体。

$$ \sim T = \text{Uni} - T $$

#### 2.3.7 析取/合取（`DiSet` / `ConSet`）
本节讨论的是**类型逻辑层**的“或/与”正规形，而不是值层的数据容器。

- `DiSet{ ... }`：析取（并类型 / Union type）的规范形
- `ConSet{ ... }`：合取（交类型 / Intersection type）的规范形

##### 析取集（DiSet）
`DiSet` 表示“可能是这些之一”（逻辑 $\lor$）。其规范化遵循结合/交换/幂等等价，从而**不存在可观察的嵌套 `DiSet`**。

**规范化（定义等价 `≡`）**：

- **扁平化**：`DiSet{ ..., DiSet{ X... }, ... } ≡ DiSet{ ..., X..., ... }`
- **去重（幂等）**：`DiSet{ ..., A, ..., A, ... } ≡ DiSet{ ..., A, ... }`
- **单元素消除**：`DiSet{ A } ≡ A`
- **空析取**：`DiSet{ } ≡ Never`

**子类型规则**：

- 对于 `DiSet{A...}` 与 `DiSet{B...}`：
  - 若 \( \forall x \in \{A...\}, \exists y \in \{B...\}, x <: y \), 则 `DiSet{A...} <: DiSet{B...}`

> 注（非规范性）：分支越多越宽；左边每个分支都能“提升到”右边某个分支，则左更窄。

##### 合取集（ConSet）
`ConSet` 表示“同时满足这些约束”（逻辑 $\land$）。其规范化同样遵循结合/交换/幂等等价，从而**不存在可观察的嵌套 `ConSet`**。

**规范化（定义等价 `≡`）**：

- **扁平化**：`ConSet{ ..., ConSet{ X... }, ... } ≡ ConSet{ ..., X..., ... }`
- **去重（幂等）**：`ConSet{ ..., A, ..., A, ... } ≡ ConSet{ ..., A, ... }`
- **单元素消除**：`ConSet{ A } ≡ A`
- **空合取**：`ConSet{ } ≡ Uni`

**子类型规则**：

- `ConSet{A, B} <: A` 且 `ConSet{A, B} <: B`
- 若 `C <: A` 且 `C <: B`, 则 `C <: ConSet{A, B}`


#### 2.3.8 符号（Symbol）
每一个符号都是一个全局唯一的构体。

* **不可访问性**: 对符号的任意 key 访问都返回 `None`，但在定义上其与 `None` 不相等，在定义上，其有一个隐式的、不可见的唯一标识符。

#### 2.3.9 名义符号集（NominalSet）
用于实现名义系统的构体。它是一个 ConSet，被专用于标识名义，和记录名义的继承关系。

$$
\text{NominalSet} = \{ \text{NominalKey}: \text{NominalOfNominal} \} \cup ConSet \{ \upsilon_k \} \\
$$

##### 名义符号（NominalSymbol）
在名义符号集中使用的，用于指定名义的符号称为名义符号。

##### 名义的核心常量
以下这些符号因为有循环定义问题，所以作为公理化存在：
* **名义符号的名义（$\text{NominalOfNominal}$）**：是一个名义符号集，用于区分构体是否是一个名义符号集。
* **名义属性（$\text{NominalKey}$）**：是一个符号，它的在构体中通常作为键存在，其对应的值是当前构体的名义符号集。

##### 名义继承
若类型 $T$ 的名义符号集为 $S_T=\{ \upsilon_T \}$，要构建其子类型 $U$：
1. 创建新符号 $\upsilon_U$
2. 构造 $S_U = S_T \cup \{ \upsilon_U \}$
3. 由 $S_U <: S_T$，得 $U <: T$

##### 具名空间（NamedMorph）
名义属性为名义符号集的构体称为具名空间。

$$
\text{NamedMorph}=\{ \text{NominalKey}: \text{NominalSet}, ... \}
$$


### 2.3.10 具名空间构造器

通过 `Nominal.CreateMorph` 创建的具名空间（NamedMorph）不仅仅是类型定义，它自动获得**构造器**能力。

#### 构造调用语法
具名空间 `T` 可以像函数一样被调用：`T { ...args }`。这提供了一种基于原型的对象构造方式。

#### 构造语义
调用 `T { ... }` 等价于执行以下步骤：

1.  **参数映射**：将传入的实参映射到 `T` 的属性键上。
    *   **顺序依据**：映射依据 `T` 定义时的**键声明顺序**。实现必须保留 `CreateMorph` 传入对象的键顺序元数据。
    *   **映射规则**：遵循 **4.3.3** 定义的函数参数绑定算法（命名优先，位置补齐）。
2.  **实例化覆盖**：生成一个新的构体，其结构为 `{ ...T, ...mapped_args }`。
3.  **类型检查**：对于每一个被覆盖的键 `k`，验证 `mapped_args[k] <: T[k]`。即新值必须符合原属性的类型约束。

#### 示例

```morf
// 定义 Point 类型，确立了 x, y, z 的顺序
let Point = Nominal.CreateMorph { 
  x: Number, 
  y: Number,
  z?: Number // z 是可选的
}

// 1. 混合参数 (命名优先，位置补齐)
// b: 2 显式绑定
// 1 作为第一个位置参数，匹配第一个未绑定的键 -> a (假设定义顺序为 a,b,c)
// 注意：本例中 Point 定义顺序为 x, y, z
let p = Point { y: 20, 10 }
// 解析：
// - y 显式绑定为 20
// - 10 匹配第一个未绑定键 -> x
// - z 为可选属性且未提供，默认为 None
// 结果: { ...Point, x: 10, y: 20, z: None }

// 2. 类型检查
// Point { x: "error" } // 错误：String 不是 Number 的子类型
```

### 2.4 复合结构

#### 2.4.1 函数
参数化的构体构造器。
$$
f: (\text{Args}) \to \mathbb{T}
$$

* **构体签名**:

```morf
{
  [NominalKey]: FunctionNominal
  params: { [string]: Uni }
}
```
  
---

## 3. 运算体系

### 3.1 核心算符与优先级
内置的表达式算符，优先级从高到低如下。同一行中的算符具有相同的优先级。

| 优先级 | 算符类型 | 算符符号 | 结合性 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 属性访问 | `.`, `[]`, `<>.`, `<>[]` | 左 | 最高优先级 |
| 2 | 展开/剩余 | `...` | 右 | 前缀算符 |
| 3 | 一元算符 | `!`, `*~` (按位取反), `-` (负号), `~` (补集), `&` (取引用) | 右 | |
| 4 | 乘除求余 | `*`, `/`, `%` | 左 | 系统分派，**不可重载** |
| 5 | 加减 | `+`, `-` | 左 | 系统分派，**不可重载** |
| 6 | 移位 | `<<`, `>>` | 左 | 仅用于 Integer |
| 7 | 比较 | `<`, `>`, `<=`, `>=` | 左 | 系统分派，**不可重载** |
| 8 | 相等 | `==`, `!=` | 左 | 系统分派，**不可重载** |
| 9 | 按位与 | `*&` | 左 | 仅用于 Integer |
| 10 | 按位异或 | `*^` | 左 | 仅用于 Integer |
| 11 | 按位或 | `*|` | 左 | 仅用于 Integer |
| 12 | 类型算符 | `&` (交集), `\|` (并集) | 左 | 类型逻辑层运算 |
| 13 | 类型关系 | `<:` (子类型), `>:` (父类型) | 左 | 静态关系判定 |
| 14 | 逻辑与 | `&&` | 左 | 短路求值 |
| 15 | 逻辑或 | `||` | 左 | 短路求值 |
| 16 | 空值合并 | `??` | 左 | 短路求值 |
| 17 | 赋值 | `=`, `+=`, `-=`, `*=`, `/=` 等 | 右 | 最低优先级 |

> **注（不可重载）**: 本规范明确规定，Morf 的二元算符（如 `+`, `-`, `*` 等）在当前版本中**不允许用户重载**。其语义由系统内置的 `Promote` 和 `Impl` 机制（如 `ArithC`）统一分派，以保证语义的一致性与可预测性。

### 3.2 类型运算符

本节定义类型逻辑层的核心运算符在语法层的表示，以及它们在类型逻辑层的规范化结果。

- **析取（并类型）**：`A | B` 的类型逻辑规范形必须为 `DiSet{A, B}`，并遵循 `DiSet` 的扁平化/去重/单元素消除/空析取规则（见 2.3.7）。
- **合取（交类型）**：`A & B` 的类型逻辑规范形必须为 `ConSet{A, B}`，并遵循 `ConSet` 的扁平化/去重/单元素消除/空合取规则（见 2.3.7）。若约束不可满足，实现必须将其规范化为 `Never`。
- **补集**：`~A` 表示 `Uni` 中不属于 `A` 的部分；其语义模型解释为 `Uni - A`（见 2.3.6）。实现可以采用等价的逻辑归约表示，但必须保持与子类型判定一致。

#### 3.2.1 前缀语法糖

为了方便在多行中书写联合或交叉类型，Morf 允许在类型表达式的首项前添加 `|` 或 `&`，其语义与省略该符号相同。

* **前缀并集**: `| A | B` 等价于 `A | B`。
* **前缀交集**: `& A & B` 等价于 `A & B`。

```morf
let MultiLineUnion = 
  | TypeA
  | TypeB
  | TypeC
```

### 3.3 展开与剩余参数算符

展开/剩余参数算符 `...` 是一个前缀算符，在不同语境下具有互逆的语义：

* **展开**：在构造表达式中使用，将集合"拆开"并插入到目标位置
* **剩余参数**：在解构/定义中使用，将多个元素"收集"成一个集合

#### 3.3.1 展开语义

##### 构体展开

在构体构造中，`...` 将源构体的所有键值对展开到目标位置。

* **语法**: `{ ...source, key: value }`
* **语义**: 以**从左到右**顺序求值各个展开源与显式键值对，并依序合并到新构体；当存在同名键冲突时，**后出现者必须覆盖先出现者**。
* **类型**: 展开结果的类型为 `source` 类型与新增属性的交集

**示例**:
```morf
let base = { x: 1, y: 2 }
let extended = { ...base, z: 3 }
// extended = { x: 1, y: 2, z: 3 }

// 后来者覆盖
let overridden = { ...base, x: 10 }
// overridden = { x: 10, y: 2 }

// 多次展开
let merged = { ...base, ...{ z: 3, w: 4 }, x: 100 }
// merged = { x: 100, y: 2, z: 3, w: 4 }
```

##### 函数调用展开

在函数调用中，`...` 将构体的所有属性作为参数展开传递。

* **语法**: `f{ ...args, key: value }`
* **语义**: 以从前到后顺序合并实参构体；显式参数必须覆盖同名参数。合并后的构体作为一次调用的实参构体。

**示例**:
```morf
let params = { x: 1, y: 2 }
let add = (x, y) { x + y }

add{ ...params }        // 等价于 add{ x: 1, y: 2 }
add{ ...params, y: 10 } // 等价于 add{ x: 1, y: 10 }
```

##### 序列展开

在序列构造中，`...` 将序列的所有元素按顺序展开。

* **语法**: `[...seq1, item, ...seq2]`
* **语义**: 将序列元素按顺序展开并合并

**示例**:
```morf
let arr1 = [1, 2, 3]
let arr2 = [4, 5]
let combined = [...arr1, ...arr2]
// combined = [1, 2, 3, 4, 5]

let withExtra = [0, ...arr1, 99]
// withExtra = [0, 1, 2, 3, 99]
```

#### 3.3.2 剩余参数语义

在函数参数定义中，`...` 用于收集剩余的参数。这与展开语义相反：不是"拆开"而是"收集"。

##### 位置参数收集：`...[]params`

使用 `...[]` 收集所有未匹配的位置参数（数字索引键）。

* **语法**: `(...[]params) { expr }`
* **语义**: `params` 接收所有剩余位置参数，组成序列（`Seq`）
* **类型**: `params` 的类型为 `Seq`

**示例**:
```morf
// 收集所有位置参数
let collect = (...[]xs) { xs }
collect{ 1, 2, 3 }  // xs = [1, 2, 3]

// 混合使用
let first_and_rest = (head, ...[]tail) { { head, tail } }
first_and_rest{ 1, 2, 3, 4 }
// head = 1, tail = [2, 3, 4]
```

##### 命名参数收集：`...params`

使用 `...` 收集所有未匹配的命名参数（非数字键）。

* **语法**: `(...params) { expr }`
* **语义**: `params` 接收所有剩余命名参数，组成构体
* **类型**: `params` 的类型为构体

**示例**:
```morf
// 收集所有命名参数
let collect_props = (...props) { props }
collect_props{ x: 1, y: 2, z: 3 }
// props = { x: 1, y: 2, z: 3 }

// 混合使用
let with_name = (name, ...attrs) { { name, attrs } }
with_name{ name: "Morf", version: 1, author: "Me" }
// name = "Morf", attrs = { version: 1, author: "Me" }
```

##### 混合参数模式

可以同时使用命名参数、位置收集和命名收集，实现复杂的参数匹配。

* **语法**: `(a, b, ...[]xs, ...ys) { expr }`
* **匹配规则**:
  1. 优先匹配显式命名的参数
  2. 剩余位置参数按顺序匹配未绑定的命名参数
  3. `...[]xs` 收集剩余的位置参数
  4. `...ys` 收集剩余的命名参数

**示例**:
```morf
let complex = (a, b, ...[]xs, ...ys) { { a, b, xs, ys } }

complex{ b: 1, c: 2, 3, 4, 5 }
// 匹配过程：
// 1. b: 1 显式匹配到参数 b
// 2. c: 2 没有对应命名参数，进入 ys
// 3. 位置参数 0: 3, 1: 4, 2: 5
// 4. a 吸收第一个位置参数 3
// 5. xs 收集剩余位置参数 [4, 5]
// 结果: a = 3, b = 1, xs = [4, 5], ys = { c: 2 }
```

#### 3.3.3 类型层面的展开

展开运算符在类型计算中遵循**结构化覆盖**规则，而非简单的交集。

* **覆盖规则**: `{ ...A, ...B }` 的结果类型是一个新的构体类型。对于 A 和 B 中共有的键，B 的类型约束**覆盖** A 的类型约束（类似于值层面的行为）。
* **非交集**: `{ x: 1 } & { x: 2 }` 是 `Never`（互斥），但 `{ ...{x: 1}, ...{x: 2} }` 是 `{ x: 2 }`。
* **子类型关系**: 展开操作产生的新类型与原类型之间通常没有直接的子类型关系，除非结构恰好兼容。

**示例**:
```morf
let TypeA = { x: Number, y: String }
let TypeB = { x: String, z: Boolean }

let MergedType = { ...TypeA, ...TypeB }
// MergedType ≡ { x: String, y: String, z: Boolean }
// 注意 x 的类型变成了 String (来自 TypeB)
```

#### 3.3.4 展开与不可变性

由于 Morf 的构体是不可变的，展开运算符总是创建新的构体，而不是修改原有对象。

**示例**:
```morf
let original = { x: 1 }
let copy = { ...original }

// original 和 copy 是不同的构体
// 但可能共享内部结构（实现细节）
```

### 3.4 访问运算符

访问运算符用于从构体中获取属性值。Morf 提供两种访问语法：点号访问和方括号访问。

#### 3.4.1 点号访问

点号访问用于访问字符串字面量键。

* **语法**: `shape.identifier`
* **语义**: 访问构体中键为字符串 `"identifier"` 的属性
* **键类型**: 键必须是合法的标识符（字母开头，包含字母、数字、下划线）
* **返回值**: 返回对应的属性值；若键不存在，返回 `None`

**示例**:
```morf
let obj = { x: 1, y: 2, name: "Morf" }

obj.x      // 1
obj.name   // "Morf"
obj.z      // None（键不存在）
```

**链式访问**:
```morf
let nested = { 
  user: { 
    profile: { 
      name: "Alice" 
    } 
  } 
}

nested.user.profile.name  // "Alice"
nested.user.settings      // None
nested.user.settings.theme // None（None 的传染性，见 2.3.4）
```

#### 3.4.2 方括号访问

方括号访问用于访问任意类型的键，包括构体键、动态计算的键等。

* **语法**: `shape[keyExpr]`
* **语义**: 先求值 `keyExpr`，然后使用结果作为键访问构体
* **键类型**: 键可以是任意构体（字符串、符号、数字等）
* **返回值**: 返回对应的属性值；若键不存在，返回 `None`

**基本示例**:
```morf
let obj = { x: 1, y: 2 }

obj["x"]        // 1，等价于 obj.x
obj["y"]        // 2

// 动态键
let key = "x"
obj[key]        // 1
```

**构体键示例**:
```morf
// 使用符号作为键
let sym = Symbol.Create{}
let secretData = { [sym]: "Hidden Value" }

secretData[sym]       // "Hidden Value"
secretData.sym        // None（点号访问查找字符串键 "sym"）
```

**数字键示例**:
```morf
let tuple = [10, 20, 30]

tuple[0]        // 10
tuple[1]        // 20
tuple[2]        // 30
tuple.length    // 3（length 是字符串键）
```

#### 3.4.3 点号与方括号的等价性

对于字符串键，点号访问和方括号访问是等价的：

```morf
obj.key  ≡  obj["key"]
```

但是：
- 点号只能访问字面标识符
- 方括号可以访问任意表达式计算出的键

#### 3.4.4 与 Impl 系统的集成

访问运算符与 Impl 系统集成。当数据层面未找到对应键时，系统会自动在适用的 Impl 中查找同名方法（详见第 10 章）。

**查找顺序**:
1. **数据优先**: 首先检查构体自身是否包含该键
2. **Impl 兜底**: 若数据层面未找到，在适用的 Impl 中查找方法

**显式 Impl 指定**:
当需要显式指定使用哪个 Impl，或绕过数据遮蔽时，使用尖括号语法：

* **点号形式**: `shape<ImplId>.method`
* **方括号形式**: `shape<ImplId>[keyExpr]`

```morf
let obj = { 
  value: 100,
  getValue: "data"
}

// 隐式访问：数据优先
obj.getValue              // "data"

// 显式 Impl：绕过数据层
obj<DataOps>.getValue{}   // 100
```

完整的 Impl 系统规则、继承、冲突解决等详见第 10 章。

#### 3.4.5 访问运算符的类型计算

访问运算符的返回类型取决于被访问构体的类型和键的类型。

本节同时给出运行时求值语义与静态类型计算规则。实现必须保证两者一致：若表达式经类型检查成立，则运行时求值不得产生违反该类型结论的值（除 `Never` 坍缩语义外）。

##### 运行时语义（数据访问）

令 `GetData(v, k)` 表示对运行时值 `v` 进行“数据层键查找”（不触发 Impl 兜底）。其行为必须满足：

- 若 `v == None`，则 `GetData(v, k) == None`。
- 否则若 `v` 在数据层显式包含键 `k`，则 `GetData(v, k)` 等于该键对应的值。
- 否则 `GetData(v, k) == None`。

点号访问 `E.id` 的运行时键必须为字符串键 `"id"`；方括号访问 `E[keyExpr]` 的运行时键必须为 `keyExpr` 求值得到的值。

##### 运行时语义（Impl 兜底）

当且仅当点号/方括号访问发生在“可调用上下文”的方法位（即形如 `E.Method{ ... }`、`E[Key]{ ... }`、`E<ImplId>.Method{...}`、`E<ImplId>[Key]{...}`）时，实现必须按本规范的 Impl 查找规则进行兜底分派，并按方法修饰符进行脱糖调用（普通方法注入 `self`，静态方法不注入）。

> 注：这条约束避免了“仅访问但不调用”时引入不可预测的隐式方法值（例如 `let m = obj.foo` 的语义）。若实现希望支持“绑定方法值”，必须以额外的、可显式辨识的值形态引入（非本版本规范所要求）。

##### 静态类型计算

为定义访问的静态类型，先定义“键投影” `T[k]`（见 2.2.2）：

- 对于点号访问 `E.id`，其键投影使用 `k = "id"`。
- 对于方括号访问 `E[keyExpr]`，若 `keyExpr` 可在类型层归约为某个**单例键** `k`（例如字符串字面量、符号单例、数字单例等），则使用该 `k`；否则其结果类型必须保守地取为 `Uni`。

**规则（构体访问）**：若表达式 `E` 的类型为构体类型项 `T`，则：

- `E.id` 的类型必须为 `T["id"]`。
- 若 `keyExpr` 可静态确定为单例键 `k`，则 `E[keyExpr]` 的类型必须为 `T[k]`；否则类型为 `Uni`。

**规则（对 `DiSet` 的分布）**：若 `E` 的类型为 `DiSet{T1, T2, ...}`，则访问操作必须对每个分支分布，并将结果规范化：

```morf
let U = DiSet{ { x: Number }, { x: String } }
// U.x 的类型为 DiSet{ Number, String }
```

**规则（对 `None`）**：`None.k` 与 `None[anything]` 的类型必须为 `None`。

#### 3.4.6 优先级与结合性

访问运算符具有最高优先级（高于所有二元运算符），采用左结合。

```morf
obj.a.b.c     // 从左到右：((obj.a).b).c
arr[0][1]     // 从左到右：(arr[0])[1]
obj.method{}  // 先访问 obj.method，再调用结果
```

**与其他运算符的组合**:

```morf
obj.method{ arg }           // 访问后调用
obj<Impl>.method{ arg }     // 显式 Impl + 访问 + 调用
obj[key]{ arg }             // 动态访问后调用
```

### 3.5 键定义语法

在构造构体时，Morf 支持三种键定义形式，用于灵活地描述属性与约束。

#### 3.5.1 字面量键

* **语法**: `{ Key: Value }`
* **语义**: 键是一个字符串字面量 `"Key"`。这是最常用的形式。
* **等价性**: 等价于 `{ ["Key"]: Value }`。

#### 3.5.2 可选属性键（? 语法）

* **语法**: `{ Key?: Type }`
* **语义**: 这是一个语法糖，表示该属性是可选的。
* **等价性**: 等价于 `{ Key: Type | None }`。
* **构造行为**: 在使用具名空间构造器（见 2.3.10）时，若未提供该属性的值，则其值默认为 `None`。

#### 3.5.3 计算键

* **语法**: `{ [Expr]: Value }`
* **语义**: 先求值表达式 `Expr`，将结果作为该属性的键。
* **用途**: 用于使用符号、变量或动态计算的值作为键。

#### 3.5.4 范围键

* **语法**: `{ [...Type]: Value }` 或 `{ [...]: Value }`
* **语义**: 这是一个**全量约束**。表示对于任何键 `k`，只要满足 `k <: Type`，则该属性的值均为 `Value`。
* **简写形式**: `{ [...]: Value }` 等价于 `{ [...Uni]: Value }`，表示对所有键的默认约束。
* **冲突处理**: 
    - 如果多个范围键覆盖了同一个具体的键，则遵循“后来者覆盖”原则。
    - 具体键（字面量键或计算键）的优先级高于范围键。

### 3.6 算术运算符

Morf 提供标准的算术运算符，用于数值计算与字符串拼接。

* **加法**: `a + b`
* **减法**: `a - b`
* **乘法**: `a * b`
* **除法**: `a / b`
* **取余**: `a % b`
* **负号**: `-a` (一元)

#### 3.6.1 运算规则

* **数值运算**: 当操作数均为数值类型时，执行数学运算。
  * **类型提升**: 混合类型的数值运算会自动提升到公共类型（见 5.4.4）。
  * **溢出检查**: 默认启用溢出检查，溢出时抛出异常（见 5.4.7）。
  * **除零**: 整数除零引发异常；浮点数除零遵循 IEEE 754（产生 `Infinity` 或 `NaN`）。
* **字符串拼接**: `+` 运算符可用于 `String + String`，表示字符串连接。
* **不可重载**: 用户无法重载这些运算符。

```morf
let x = 10 + 20        // 30
let s = "Hello" + "!"  // "Hello!"
let f = 3.14 * 2.0     // 6.28
```

### 3.7 移位运算符

移位运算符仅适用于**整数类型**（Integer）。

* **左移**: `a << n`。将 `a` 的二进制位向左移动 `n` 位，右侧补 0。
* **右移**: `a >> n`。将 `a` 的二进制位向右移动 `n` 位。
  *   对于**无符号整数** (Unsigned)，执行逻辑右移（高位补 0）。
  *   对于**有符号整数** (Signed)，执行算术右移（高位补符号位）。

```morf
let a: U8 = 0b0000_0001
let b = a << 2         // 0b0000_0100

let c: I8 = -8         // 0b1111_1000
let d = c >> 1         // 0b1111_1100 (-4)
```

### 3.8 比较运算符

比较运算符返回布尔值 `Bool` (`true | false`)。

#### 3.8.1 相等性比较

* **等于**: `a == b`
* **不等于**: `a != b`

**语义**:
* **结构化相等**: 对于构体（包括序列、元组等），`==` 默认执行深度结构化比较。当且仅当所有键值对递归相等时，两个构体相等。
* **mut 变量**: 由于 `mut` 变量在表达式中会自动解包（Auto-dereference），`==` 比较的是其**当前值**，而非槽位身份。
  *   若需比较槽位身份，必须使用 `&` 运算符获取引用（见 3.13）。
* **名义身份**: 对于 `Symbol`，比较其唯一身份标识。
* **类型安全**: `==` 允许比较任意类型的值。若两个值的类型交集为 `Never`（完全不兼容），实现可以发出静态警告，且运行时结果恒为 `false`。

```morf
let p1 = { x: 1, y: 2 }
let p2 = { x: 1, y: 2 }
p1 == p2  // true (结构相等)

let s1 = Symbol.Create{}
let s2 = Symbol.Create{}
s1 == s2  // false (每一个 Symbol 都是唯一的)
```

#### 3.8.2 序关系比较

* **小于**: `a < b`
* **大于**: `a > b`
* **小于等于**: `a <= b`
* **大于等于**: `a >= b`

**语义**:
*   仅定义在支持序关系的类型上（如 Number, String）。
*   对于数值，遵循数学大小关系。
*   对于字符串，遵循字典序（Lexicographical Order）。

### 3.9 数值位运算符

为了避免与类型逻辑运算符（`&`, `|`, `~`）混淆，并明确区分“集合操作”与“底层位操作”，Morf 引入了一组带有 `*` 前缀的专用位运算符。

> **Q: Number 本体何来的位概念？**
> A: 抽象的 `Number` 类型是数学上的数值集合，不具有机器表示的“位”概念。因此，本节定义的位运算符**仅对具体整数类型（Integer: I8-I64, U8-U64）有效**。对 `Float` 或抽象 `Number` 使用位算符将导致类型错误。

* **按位与**: `a *& b`
* **按位或**: `a *| b`
* **按位异或**: `a *^ b`
* **按位取反**: `*~a` (一元算符)

这些算符的行为遵循标准二进制补码运算规则。参与运算的操作数将被提升（Promote）到相同的整数类型后进行计算。

```morf
let x: U8 = 0b0000_1111
let y: U8 = 0b0000_1010

x *& y   // -> 0b0000_1010
x *| y   // -> 0b0000_1111
*~x      // -> 0b1111_0000
```

### 3.10 逻辑运算符

逻辑运算符用于布尔逻辑组合，支持短路求值。

* **逻辑与**: `a && b`
* **逻辑或**: `a || b`
* **逻辑非**: `!a`

#### 3.10.1 类型约束与真值

Morf 采用严格的布尔逻辑。
*   操作数必须是 `Bool` 类型（`true` 或 `false`）。
*   不提供隐式的 "Truthy/Falsy" 转换（如将 `0` 或 `None` 视为假）。若需判断是否存在，应显式使用比较（如 `val != None`）。

#### 3.10.2 短路求值

*   `a && b`: 若 `a` 为 `false`，则直接返回 `false`，不求值 `b`。
*   `a || b`: 若 `a` 为 `true`，则直接返回 `true`，不求值 `b`。

```morf
let check = (x) {
  x != None && x > 0
}
```

### 3.11 空值合并运算符

空值合并运算符 `??` 提供了一种处理 `None` 的便捷方式。

* **语法**: `L ?? R`
* **语义**:
    1.  求值 `L`。
    2.  若 `L` 不为 `None`，则结果为 `L`（此时 `R` **不求值**，即短路）。
    3.  若 `L` 为 `None`，则求值并返回 `R`。
* **类型**: 结果类型为 `(Type(L) - None) | Type(R)`。

```morf
let val = maybeNone ?? "default"
// 等价于
let val = Switch {
  Case { maybeNone != None, maybeNone },
  "default"
}
```

### 3.12 赋值运算符

Morf 支持基本的赋值与复合赋值操作。赋值操作仅对 `mut` 声明的变量槽位（Slot）有效（见第 8 章）。

* **基本赋值**: `a = b`。将 `b` 的值写入 `a` 对应的槽位。表达式的值为 `b`（右值）。
* **复合赋值**: `+=`, `-=`, `*=`, `/=`, `%=`, `??=`, `*&=`, `*|=`, `*^=` 等。
* **语义**: `a op= b` 语义上等价于 `a = a op b`，但 `a` 的地址计算（如果涉及属性访问）只进行一次。

### 3.13 取引用运算符

为了在需要时获取 `mut` 变量的槽位本身（而不是其值），Morf 引入了一元前缀运算符 `&`。

* **语法**: `&variable`
* **语义**: 获取 `variable` 对应的内存槽位（Slot）的引用。
* **类型**: 若 `x` 的类型为 `T`，且 `x` 是 `mut` 绑定的，则 `&x` 的类型为 `Slot{T}`（一种特殊的系统内建类型）。
* **用途**:
    1.  **身份比较**: 判断两个变量是否指向同一个存储槽位。
    2.  **传递引用**: 将槽位传递给接受 `mut` 参数的函数（虽然函数调用时通常会自动处理，但在某些泛型上下文中显式取址可能更清晰）。

```morf
mut a = 1
mut b = 1

a == b   // true  (值相等)
&a == &b // false (槽位不同)

let refA = &a // refA 持有对 a 的引用
```

### 3.14 变量绑定与解构

Morf 支持在 `let` 声明和赋值语句中使用模式匹配进行解构。

#### 3.14.1 基本绑定与类型断言

*   **`let` 绑定**: `let x = Expr`
    *   **语义**: 将 `Expr` 的求值结果绑定到变量名 `x`。
    *   **类型**: 变量 `x` 的类型**精确等于** `Expr` 的结果类型（保留单例信息，不进行宽化）。

*   **带类型标注的 `let`**: `let x: T = Expr`
    *   **语义**: 这是一种**静态类型断言 (Assertion)**。
    *   **检查**: 编译器验证 `Expr` 的类型是否是 `T` 的子类型（`Type(Expr) <: T`）。
    *   **结果类型**: 变量 `x` 的类型**依然保持为 `Expr` 的精确类型**，而非标注类型 `T`。编译器不得因类型标注而丢失值的具体信息。

#### 3.14.2 构体解构

* **基本语法**: `let { key1, key2 } = shapeExpr`
* **重命名**: `let { sourceKey: newName } = shapeExpr`
* **默认值**: `let { key = defaultValue } = shapeExpr`
  *   若对应键的值为 `None`，则使用 `defaultValue`。
* **剩余属性**: `let { x, ...rest } = shapeExpr`
  *   `rest` 收集除 `x` 以外的所有剩余属性为一个新的构体。

**示例**:
```morf
let user = { id: 1, name: "Alice", meta: "data" }

// 基本解构
let { id, name } = user
// id = 1, name = "Alice"

// 重命名与默认值
let { id: uid, role = "Guest" } = user
// uid = 1, role = "Guest" (因为 user 中没有 role)

// 剩余属性
let { meta, ...coreInfo } = user
// coreInfo = { id: 1, name: "Alice" }
```

#### 3.14.3 序列解构

由于序列（Seq/Tuple）也是构体（键为数字索引），解构语法通过 `[]` 糖衣支持位置解构。

* **语法**: `let [a, b, ...rest] = seqExpr`
* **语义**: 等价于访问索引 `0`, `1` 等。
* **跳过元素**: `let [first, , third] = seqExpr`

```morf
let point = [10, 20, 30]

let [x, y] = point
// x = 10, y = 20

let [head, ...tail] = point
// head = 10, tail = [20, 30]
```

---

### 3.15 变量作用域与递归定义

为了支持递归数据结构（如链表、树）与互递归函数，Morf 采用了 **块级提升 (Block-level Hoisting)** 机制。

#### 3.15.1 提升与 Pending 状态

在一个代码块（Block）或模块（Module）的作用域内，所有通过 `let` 定义的变量名在整个作用域内都是**可见的**。

*   **初始化前**：在程序的控制流到达 `let x = ...` 语句之前，变量 `x` 处于 **"Pending" (待定)** 状态。
*   **初始化后**：语句执行完成后，变量转为 **"Resolved" (已决)** 状态。

#### 3.15.2 递归引用规则

在 `let` 绑定的右值表达式中，允许引用当前作用域内处于 Pending 状态的变量（包括自身与其他尚未定义的变量），但必须满足**结构性引用约束**。

*   **合法引用 (Structural Reference)**：
    *   作为构体的属性值：`{ next: PendingVar }`
    *   作为类型构造器的参数：`Option{PendingVar}`
    *   作为 Union/Intersection 的成员：`A | PendingVar`
    *   在函数体（闭包）内部引用：`() { PendingVar }`
*   **非法引用 (Immediate Evaluation)**：
    *   参与立即执行的计算：`PendingVar + 1`
    *   作为被调用的函数：`PendingVar{ ... }`
    *   访问其属性：`PendingVar.prop`

**示例：互递归定义**

```morf
// 合法：Node 引用了 Pending 的 Tree
let Node = { 
  left: Tree, 
  right: Tree 
}

// 合法：Tree 引用了已决的 Node
let Tree = Node | None
```

---

## 4. 流程控制与块表达式

为了支持优雅的业务逻辑编排，Morf 引入了非严格求值的块语法。

### 4.1 块表达式
使用圆括号 `( ... )` 包裹一系列语句，构成一个块表达式。
* **求值顺序**：块内语句必须按书写顺序求值。
* **结果值**：块中最后一个表达式的值，作为整个块表达式的值。
* **词法作用域**：块表达式必须引入新的词法作用域；块内 `let/mut` 声明的绑定不得泄漏到块外。
* **示例**：`( let a = 1; f{a}; Ok{a} )`。

### 4.2 自动 Thunk
为了实现“懒执行”的控制流，Morf 引入了自动 Thunk 机制。

#### 4.2.1 参数修饰符：`wrap`
在函数定义时，可以为参数添加 `wrap` 前缀，标识该参数为“延迟求值”参数。
* **语义**: 当调用该函数时，若某个实参表达式被绑定到 `wrap` 参数，则该表达式**不得在调用点求值**，而必须被自动包装为一个零参函数 `() { ... }`（Thunk）并传入。
* **求值时机**：Thunk 仅在其被调用（`thunk{}`）时才对原表达式求值。
* **纯度**：构造 Thunk 本身必须是纯操作；表达式的 Effect 由后续调用释放并传播（见 Effect 规则）。
* **定义示例**: 
    `let Case = (c, wrap d) { { case: c, do: d } }`
* **调用示例**:
    ```javascript
    // 下面两者等价，Sys.Log{} 均不会立即执行
    Case{ x > 0, Sys.Log{ "Ok" } }
    Case{ x > 0, ( Log{ "Ok" }; true ) }
    ```

#### 4.2.2 逃逸修饰符：`directly`
如果参数被标记为 `wrap`，但调用者希望直接传递一个值（例如已经包装好的函数或特定的 Morph）而不被再次包装，则使用 `directly` 关键字。
* **语法**: `f{ directly { expr } }`
* **语义**: 当 `directly { expr }` 被绑定到某个 `wrap` 参数时，实现必须强制跳过自动 Thunk 逻辑，直接对 `expr` 求值并传递其值。
* **示例**:
    `Case{ x > 0, directly { mySavedThunk } }`

### 4.3 函数定义语法

Morf 使用圆括号 `()` 定义参数列表，大括号 `{}` 定义函数体。函数定义语法与调用语法高度统一，支持命名参数、位置参数、展开运算符等特性。

#### 4.3.1 基本定义语法

函数定义本身是一个表达式，求值结果为函数值（闭包），该闭包捕获定义时的词法环境。

* **无参函数**: `() { expr }`
* **命名参数**: `(a, b) { expr }`
* **带返回值标注**: `(args) -> ReturnType { expr }`
* **函数体**: 大括号内可以是单个表达式或包含多条语句的块

**示例**:
```morf
// 无参函数
let greet = () { "Hello" }

// 带返回值标注
let add = (x, y) -> Number { x + y }

// 多语句函数体
let compute = (n) {
  let doubled = n * 2
  let squared = doubled * doubled
  squared
}
```

#### 4.3.2 闭包与捕获语义

在 Morf 中，所有函数都是**闭包 (Closure)**。闭包由**函数代码**与**创建时的词法环境**组成。

* **捕获规则**:
  * **捕获 `let` 绑定**: 对于作用域内的不可变绑定，闭包捕获其**值**。由于值不可变，这在语义上等价于拷贝。
  * **捕获 `mut` 绑定**: 对于作用域内的 `mut` 绑定，闭包捕获其**槽位 (Slot)** 的引用。
      *   这意味着闭包内部可以读取到外部对该变量的最新修改。
      *   闭包内部对该变量的赋值也会同步修改外部变量的状态。

**示例**:
```morf
let makeCounter = () {
  mut count = 0
  
  // 返回一个闭包，它捕获了 `count` 的槽位
  () { 
    count += 1
    count 
  }
}

let c = makeCounter{}
c{} // 1
c{} // 2
```

#### 4.3.3 参数与调用的映射关系

函数调用使用大括号 `{}` 进行，调用时的参数会被映射到一个构体（Morph）。

本节定义“实参项列表 → 形参绑定”的规范性算法。该算法的目标是：

- 明确参数匹配优先级（命名优先、位置补齐、剩余收集）；
- 明确求值顺序（严格左到右），并与 `wrap/directly` 的非严格语义一致；
- 使得实现可在不引入运行时歧义的前提下实现关键字参数、展开与剩余参数。

##### 实参项

函数调用 `f{ ... }` 的实参由逗号分隔的“实参项”构成。实现必须支持至少以下形态：

- **位置实参**：`Expr`
- **命名实参**：`name: Expr`（其中 `name` 是标识符；其键为字符串 `"name"`）
- **展开实参**：`...Expr`（其中 `Expr` 必须求值为构体）
- **逃逸实参**：`directly { Expr }`（仅对绑定到 `wrap` 形参时有意义）

##### 绑定算法（规范性）

令被调用的函数值为 `F`，其形参列表为按声明顺序排列的序列。每个形参是下列之一：

- 普通形参：`p` 或 `p: Type` 或 `wrap p` 或 `wrap p: Type`
- 位置剩余形参：`...[]xs`（至多一个）
- 命名剩余形参：`...ys`（至多一个）

实现必须按如下步骤完成一次调用的形参绑定与求值。

**步骤 1：左到右收集实参贡献**

实现必须从左到右处理实参项，并构造一个“实参构体” `A`。其中每个条目来自以下之一：

- 对于展开实参 `...E`：实现必须立即对 `E` 求值，得到构体 `S`，并将 `S` 的全部键值对合并进 `A`；若键冲突，后出现者覆盖先出现者。
- 对于命名实参 `name: E`：实现必须在 `A` 中写入键 `"name"` 的条目，其值为一个**待定实参** `ArgExpr(E)`，并记录其在源代码中的相对顺序。若同一键在 `A` 中被再次写入，后出现者覆盖先出现者。
- 对于位置实参 `E`：实现必须在 `A` 中写入键 `i`（从 0 开始递增的整数键）的条目，其值为 `ArgExpr(E)`，并记录顺序；随后 `i += 1`。
- 对于逃逸实参 `directly { E }`：其本身不是独立的键值对；它仅作为某个命名/位置实参的 `E` 形式出现，用于在步骤 3 中抑制自动 wrap。

> 注：`ArgExpr(E)` 表示“尚未求值的实参表达式”。该结构仅是规范性描述；实现可以用闭包、IR 节点或 thunk 记录之。

**步骤 2：形参匹配（命名优先，位置补齐，剩余收集）**

在此步骤中，实现不得对任何 `ArgExpr` 求值，仅决定每个形参绑定到 `A` 的哪个键（若有）。

- **命名匹配**：对每个普通形参 `p`（含 `wrap` 与类型标注），若 `A` 中存在键 `"p"`，则该形参绑定到该条目。
- **位置补齐**：对仍未绑定的普通形参，按声明顺序依次从 `A` 中取用键 `0, 1, 2, ...`（跳过不存在的键），并绑定到该条目。
- **位置剩余收集**：若声明了 `...[]xs`，则 `xs` 绑定为一个序列（`Seq`），其元素为 `A` 中所有**未被消耗**的整数键条目按键从小到大排列后的值（仍为 `ArgExpr`，待步骤 3 处理）。
- **命名剩余收集**：若声明了 `...ys`，则 `ys` 绑定为一个构体，包含 `A` 中所有**未被消耗**且非整数键的条目（值仍为 `ArgExpr`，待步骤 3 处理）。
- **未绑定形参**：任何在以上规则后仍未绑定到实参的普通形参，其值必须为 `None`。

若某个 `ArgExpr` 同时被两个形参消耗（例如通过实现错误导致），实现必须报错或坍缩为 `Never`；不得产生未定义行为。

**步骤 3：按 `wrap/directly` 规则实现求值**

对步骤 2 中绑定到 `ArgExpr(E)` 的每个普通形参 `p`：

- 若 `p` 带有 `wrap`，且该 `ArgExpr` 的语法形态不是 `directly { E }`，则该形参的值必须为 Thunk `() { E }`，并且 **E 不得在调用点求值**。
- 否则实现必须对 `E` 求值，并将其结果作为该形参的值。

对 `...[]xs` 与 `...ys` 中的每个 `ArgExpr`，实现必须按同样规则递归处理：若容器中元素最终绑定到 `wrap` 形参则构造 thunk，否则求值。容器本身的构造应保持左到右的实参求值顺序：所有“需要立即求值”的 `E` 必须按其在源代码中出现的顺序求值（展开实参的求值顺序也参与其中）。

##### 语法等价（示例级）

`f{ a, b }` 等价于 `f{ a: a, b: b }`（其中 `a`、`b` 为变量名且同时也是形参名）。

```morf
let add = (x, y) { x + y }
add{ x: 1, y: 2 }
add{ 1, 2 }
```

#### 4.3.3 剩余参数模式

在函数参数定义中，可以使用剩余参数算符 `...` 收集未匹配的参数。详细语法和语义见 **3.3.2 剩余参数语义**。

**快速参考**:

* **位置参数收集**: `(...[]params) { expr }` - 收集所有剩余位置参数为序列
* **命名参数收集**: `(...params) { expr }` - 收集所有剩余命名参数为构体
* **混合模式**: `(a, b, ...[]xs, ...ys) { expr }` - 同时使用命名参数和剩余参数

**示例**:
```morf
// 位置参数收集
let sum = (...[]nums) { 
  nums.reduce{ (a, b) { a + b }, 0 } 
}
sum{ 1, 2, 3, 4 }  // 10

// 命名参数收集
let makeConfig = (name, ...options) { 
  { name, ...options } 
}
makeConfig{ name: "App", debug: true, port: 3000 }
// { name: "App", debug: true, port: 3000 }

// 混合模式
let complex = (first, ...[]rest, ...props) { 
  { first, rest, props } 
}
complex{ 1, 2, 3, x: 10, y: 20 }
// { first: 1, rest: [2, 3], props: { x: 10, y: 20 } }
```

> **注**: 剩余参数模式遵循严格的优先级规则：显式命名参数 > 位置参数顺序匹配 > 位置收集 > 命名收集。一旦参数被绑定，就不能再被重新赋值。

#### 4.3.4 参数类型约束

参数默认类型为 `Uni`（全集），可以使用 `:` 指定类型约束。也可以使用 `?` 表示可选参数。

* **语法**: `(param: Type) { expr }` 或 `(param?: Type) { expr }`
* **语义**: 约束 `param` 必须是 `Type` 的子类型。若为 `?` 可选参数，则等价于 `param: Type | None`，且在调用时若未提供该参数，其值默认为 `None`。
* **类型检查**: 在调用时，传入的值必须满足类型约束。

**示例**:
```morf
// 约束参数为 Number 的子类型
let square = (x: Number) { x * x }

square{ 5 }      // ✓ 合法
square{ "text" } // ✗ 类型错误

// 可选参数示例
let greet = (name?: String) { 
  "Hello, " + (name ?? "Guest")
}
greet{}          // "Hello, Guest"
greet{ "Alice" } // "Hello, Alice"
```

#### 4.3.5 参数作为泛型

参数本身就是泛型参数，可以在类型约束中直接引用其他参数。

* **语法**: `(T, value: T) { expr }`
* **语义**: 参数 `T` 作为类型，`value` 被约束为 `T` 的实例
* **应用**: 支持高阶类型编程和泛型函数

> **注**: 由于 Morf 中类型和值是统一的，类型构造器（如 `List`, `Optional`）可以作为参数传递，实现了对高阶类型（HKT）的自然支持。

**示例**:
```morf
// 泛型身份函数
let identity = (T, x: T) { x }

identity{ Number, 42 }    // 返回 42
identity{ String, "Hi" }  // 返回 "Hi"

// 泛型容器构造
let make_pair = (T, a: T, b: T) { [a, b] }

make_pair{ Number, 1, 2 }     // [1, 2]
make_pair{ String, "a", "b" } // ["a", "b"]

// 显式标注泛型返回类型
// 这里的 `-> T` 表示返回值的类型必须是 T 的子类型
// 而不是说函数返回 T 这个类型对象本身
let identity = (T, x: T) -> T { x }

// 高阶类型约束
let apply_twice = (F, x, y: F{x}) { F{ F{ x } } }
// F 是一个函数，y 必须是 F{x} 的子类型

// 复杂泛型示例
let map = (T, U, f: (T) -> U, xs: Seq{T}) {
  // xs 的每个元素是 T，f 将 T 映射到 U
  // 返回 Seq{U}
}
```

**类型构造器参数**:
```morf
// 参数可以是带参数的类型构造器
let wrap_in_list = (x, y: List{x}) { y }
// y 必须是 List{x} 类型

// 约束为某个函数的应用结果
let constrained = (T, F, value: F{T}) { value }
// value 必须是 F{T} 类型
```

### 4.4 返回类型系统

Morf 的函数返回类型模型严格区分“实现推导”与“接口承诺”。这一设计旨在理清“代码实际做了什么”与“API 承诺了什么”之间的关系。

#### 4.4.1 推导返回类型 (Inferred Return)
这是基于函数体控制流与表达式推导出的真实返回类型。

* **定义（返回类型函数）**: 令函数体为 `Body`，系统基于控制流分析（CFA）与流敏感细化，推导出一个**返回类型函数** $R_{inferred}(\vec{P})$。其中 $\vec{P}$ 是形参类型环境（可包含依赖于参数的类型变量），$R_{inferred}$ 的结果允许是**分段/条件类型**，以保留“控制流即类型”的语义。
* **特性**:
  * **控制流保留**: 若分支条件依赖于形参（或由形参导出的类型谓词）且在编译期不可判定，实现应当把结果保留为条件类型（而不是立即拍扁为 Union）。
  * **精确性**: 反映了实现的真实行为。
  * **默认行为**: 若未显式标注返回承诺（见 4.4.2），函数对外暴露的静态签名类型可以直接是 $R_{inferred}$（一个类型函数）。

* **定义（擦除上界）**: 为服务于“仅承诺父类型、不暴露控制流细节”的接口视角，可定义擦除后的上界：
  $$
  R_{erased} \ \triangleq\ \text{Erase}(R_{inferred})
  $$
  其中 `Erase` 表示把条件/分段信息擦除为一个保守的上界（通常对应“所有分支结果的并集”）。该上界适合作为约定返回类型的候选，但不应当被当作推导返回类型本身。

```morf
let f = (x) {
  If { x > 0, 1, "error" }
}
// 推导返回类型：一个依赖于参数 x 的条件类型/类型函数
// 直观等价于 Typescript：
//   x extends Gt{0} ? 1 : "error"
//
// 若把依赖擦除，仅取对外承诺上界（约定返回类型的候选）：
//   1 | "error"
```

#### 4.4.2 约定返回类型 (Contracted Return)
这是开发者在函数签名中通过 `-> Type` 显式标注的类型约束。

* **语法**: `(args) -> Cap { ... }`
* **语义**: 声明该函数的返回值**必须**是 `Cap` 的子类型。这是一种**接口承诺**，屏蔽了实现细节。
* **校验规则**:
  * **逐次实例化校验**: 对任意一次调用（或一次泛型实例化）得到的实参类型环境 $\sigma$，实现必须验证：
        $$
        R_{inferred}[\sigma] \ <: \ Cap[\sigma]
        $$
        若不满足则报错。
  * **对外类型视图**: 当存在显式 `Cap` 时，函数对外暴露的签名返回类型应当被视为 `Cap`（实现可以内部保留 $R_{inferred}$ 用于优化/诊断，但调用者只能依赖 `Cap`）。
* **依赖类型**: `Cap` 表达式可以引用参数列表中的变量，以支持泛型约束。

```morf
// 显式承诺返回 Number (Contract)
// 即使实现推导出的类型是 I32 (Inferred)，对外也只承诺它是 Number
let add = (x, y) -> Number {
  x + y // R_inferred = I32
}
// 校验: I32 <: Number (通过)

// 依赖类型约束
let identity = (T, x: T) -> T { x }
```

#### 4.4.3 协变返回类型
在覆盖（Override）父类方法或实现接口时，函数的承诺返回类型允许协变（Covariant）。即子类方法的 **承诺上界** 可以是父类方法 **承诺上界** 的子类型。

```morf
// 假设 Base.get 的承诺上界是 Number
// 子类 Sub.get 可以承诺返回 Integer (因为 Integer <: Number)
impl Sub for ... {
  get: () -> Integer { ... }
}
```

### 4.5 控制流模式

在 Morf 中，控制流不是通过特殊的语法关键字（如 `if`, `while`）实现的，而是通过**函数**与**自动 Thunk**（`wrap` 参数）的组合来实现的。

这种设计使得用户可以定义自定义的控制流结构，与内置控制流具有同等的地位和语法体验。

#### 4.5.1 条件分支
条件分支通过 `Switch` 或 `If` 函数实现。由于分支代码块被绑定到 `wrap` 参数，它们仅在满足条件时才会被求值。

#### 4.5.2 循环与递归

Morf 中的循环并非特殊的语法结构，而是标准库提供的普通函数。

*   **While**: `While { cond, wrap body }`。只要 `cond` 为真就重复执行 `body`。
*   **Loop**: `Loop { wrap body }`。无限循环，通常配合 `break` 使用。
*   **递归**: 由于函数是头等公民且支持块级提升（3.15），直接的函数递归是处理重复逻辑的首选方式，也是函数式编程的惯用模式。

```morf
let factorial = (n) {
  If { n <= 1, 1, n * factorial{n - 1} }
}
```

### 4.6 非局部控制流与信号

为了在基于函数的控制流（如 `If`, `Switch`, `While`）中支持传统的“提前返回”或“循环中断”，Morf 将 `return`, `break`, `continue` 建模为 **控制流信号 (Control Signal)**。这是一种特殊的、隐式的代数效应。

#### 4.6.1 信号模型

*   **发射 (Emit)**: 语句如 `return x` 或 `break` 本质上发射了一个信号。这会导致当前执行流立即中断（类型为 `Never`），信号沿着调用栈向上逃逸。
*   **穿透 (Penetrate)**: 信号会自动穿透所有的 `wrap` Thunk 边界和普通函数调用栈。
*   **捕获 (Trap)**: 信号直到遇到特定的**词法边界 (Lexical Boundary)** 或 **Handler** 才会被捕获并处理。

#### 4.6.2 Return 语句

*   **语法**: `return Expr`
*   **语义**: 发射 `Signal.Return`，携带返回值。
*   **捕获边界**: **最近的词法层级函数定义**（Lexical Function Definition）。
    *   即 `let f = (...) { ... }` 定义的函数体边界。
    *   注意：传递给 `If`, `Switch` 的 `wrap` 块**不是**独立的函数定义边界（虽然底层实现为 Thunk），因此 `return` 会穿透它们，直接从宿主函数返回。这实现了直观的 **Non-local Return**。

```morf
let findUser = (users, targetId) {
  // users.each 接受一个回调函数
  users.each { user ->
    // If 是一个普通函数调用，其第二个参数是 wrap thunk
    If { user.id == targetId, 
      // 这里的 return 不会只从 If 返回，也不会只从 each 的回调返回
      // 而是作为信号穿透，直接终止 findUser 函数，并返回 user
      return user 
    }
  }
  None
}
```

#### 4.6.3 Break 与 Continue

*   **语法**: `break` / `continue`
*   **语义**: 发射 `Signal.Break` 或 `Signal.Continue`。
*   **捕获边界**: **最近的循环函数调用**（Loop Context）。
    *   标准库中的循环函数（如 `While`, `Loop`, `Iter`）内部实现了 Signal Handler，负责捕获这些信号并执行相应逻辑（终止循环或跳过当前迭代）。

```morf
let sumUntil = (nums, limit) {
  mut sum = 0
  
  // Iterate 是一个普通函数
  Iterate { nums, (n) ->
    if { sum + n > limit, break } // 发射 Break 信号，被 Iterate 捕获
    if { n < 0, continue }        // 发射 Continue 信号，被 Iterate 捕获
    sum += n
  }
  
  sum
}
```

### 4.5.3 异常与错误处理

Morf 倡导 **“能力导向 (Capability-based)”** 的错误处理哲学。

* **控制流错误（Exceptions）**：对于系统级错误或中断流程的异常（如文件未找到、网络错误），推荐使用 **动态 Impl（代数效应）** 进行处理（见 10.7）。这避免了 `Result` 类型对函数签名的污染，实现了“直接风格（Direct Style）”的编程体验。
* **数据化错误（Errors as Data）**：仅当错误需要作为业务逻辑的数据进行存储、传递或批量处理时，才使用 `Result` 类型（`Ok | Err`）。

```morf
// 使用 Impl 处理错误 (Direct Style)
let div = (a, b) {
  if b == 0 { Uni<Throw>.raise{ "ZeroDivision" } }
  a / b
}

// 在上层处理
using impl Throw = { 
  raise: (msg) { Log{ "Error: " + msg }; 0 } 
} {
  div{ 10, 0 } // -> Log "Error...", returns 0
}
```

### 4.5.4 异步与并发

Morf 采用 **“同步偏好 (Synchronous Preference)”** 或 **Direct Style** 的异步模型。

* **默认同步**：任何异步操作（如 IO）在语法上看起来都是同步阻塞的调用。编译器会自动处理底层的挂起与调度（Effect 染色）。
* **显式并发**：仅当需要通过并行执行来优化性能时，才使用 `async` 关键字获取任务句柄（Future）。

详细规范见 **12. 异步系统**。

---

## 5. 数字系统

数字即值。

### 5.1 数值定义

#### 5.1.1 整数字面量

Morf 支持多种进制的整数字面量表示。

* **十进制**: `123`, `0`, `-42`
* **二进制**: `0b` 或 `0B` 前缀，如 `0b1010`, `0b1111_0000`
* **八进制**: `0o` 或 `0O` 前缀，如 `0o755`, `0o123`
* **十六进制**: `0x` 或 `0X` 前缀，如 `0xFF`, `0x1A2B`

#### 5.1.2 浮点数字面量

浮点数必须包含小数点或指数部分。

* **小数形式**: `3.14`, `0.1`, `123.0`
* **科学计数法**: 使用 `e` 或 `E` 表示指数。
  *   `1.2e3` (1200.0)
  *   `1e-4` (0.0001)
  *   `3.14E+2` (314.0)

#### 5.1.3 数值分隔符

为了提高可读性，可以使用下划线 `_` 作为数值分隔符。分隔符可以出现在数字中间的任意位置，但不能出现在开头、结尾或小数点两侧。

*   `1_000_000` (一百万)
*   `0xFF_AA_BB` (十六进制颜色)
*   `3.14159_26535`

#### 5.1.4 语义

*   数字是**具名空间**，每一个数字都有自己独有的名义符号。
*   每一个具体的数字（如 `1` 和 `2`）都是互斥的类型。` 1 & 2 -> Never`。
* **子类型关系**: 数字之间**不存在**子类型关系。即 $1$ 不是 $2$ 的子类型，反之亦然。即 $1 \not<: 2$。
* **比较关系**: 数字之间支持比较运算。即 $1 < 2$ 为真。

### 5.2 区分 `<` 与 `<:`

* **`<` (小于)**: 这是一个比较运算符，返回布尔值。
  *   `1 < 2 -> true`
* **`<:` (子类型)**: 这是一个类型系统的关系判定。
  *   `1 <: 2 -> false` (因为它们是不同的值)
  *   `1 <: Number -> true`

### 5.3 数字集合体系

为了在类型系统中表达数值范围，Morf 0.2 引入了 **Interval** 体系。

#### 5.3.1 基础区间类型

* **`Interval`**: 所有区间类型的父接口。
* **`Lt{N}` (Less Than N)**: 集合 $\{ x \mid x < N \}$。
* **`Gt{N}` (Greater Than N)**: 集合 $\{ x \mid x > N \}$。

#### 5.3.2 有界区间

替代单一的 `Range`，支持完整的开闭区间组合：

* **`IntervalOO{Min, Max}`**: Open-Open, $(Min, Max)$, $\{ x \mid Min < x < Max \}$
* **`IntervalOC{Min, Max}`**: Open-Closed, $(Min, Max]$, $\{ x \mid Min < x \le Max \}$
* **`IntervalCO{Min, Max}`**: Closed-Open, $[Min, Max)$, $\{ x \mid Min \le x < Max \}$
* **`IntervalCC{Min, Max}`**: Closed-Closed, $[Min, Max]$, $\{ x \mid Min \le x \le Max \}$

#### 5.3.3 与 Number 的相容性

这些集合类型与具体的数字类型是**相容**的。这意味着一个具体的数字可以是这些集合的子类型。

*   若 $x < N$，则 $x <: \text{Lt}<N>$。
  *   `1 <: Lt{2}` 为 **true**。
  *   `1 & Lt{2} -> 1`。

#### 5.3.4 集合运算

*   `Lt{5} & Lt{3} -> Lt{3}`
*   `Gt{1} & Lt{3} -> IntervalOO{1, 3}`
*   `Lt{1} & Gt{3} -> Never`

## 5.4 具体数字类型体系

### 5.4.1 类型层次结构

Morf 在抽象 `Number` 之下引入一组**具体数字类型根**，用于机器运算与宿主互操作。

#### 类型继承关系（概览）

`Interval ⊇ Number ⊇ (Float | SignedInt | UnsignedInt)`

- **Float**: `F32`, `F64`（IEEE 754）
- **SignedInt**: `I8`, `I16`, `I32`, `I64`
- **UnsignedInt**: `U8`, `U16`, `U32`, `U64`

#### 子类型与互斥

```morf
I32 <: SignedInt <: Number <: Interval
U8  <: UnsignedInt <: Number <: Interval
F64 <: Float <: Number <: Interval

// 不同具体类型之间不存在子类型关系；且视为互斥
I32 ⊄ F64
U8  ⊄ I32
I32 & F64 -> Never
```

**原则**：

1. **无隐式转换**：不同具体类型间不自动转换；混合运算通过“提升”（5.4.4）统一到公共类型。
2. **字面量多态**：数字字面量在约束前属于字面量类型（5.4.2），可按上下文实例化为具体类型。
 
---

### 5.4.2 字面量类型与推断

#### 字面量类型

- **整数**字面量 `n` 的类型为 `IntLit{n}`
- **小数**字面量 `r` 的类型为 `FloatLit{r}`

字面量类型可实例化为兼容的具体数字类型：

- `IntLit{n} <: I8/I16/I32/I64` 当 `n` 落在对应值域内
- `IntLit{n} <: U8/U16/U32/U64` 当 `n` 落在对应值域内
- `IntLit{n} <: Float` 与 `FloatLit{r} <: Float` 总是成立（可能损失精度）

#### 默认推断

- **整数字面量**：无约束时推断为 `I32`
- **浮点字面量**：无约束时推断为 `F64`

#### 字面量后缀（语法糖）

```morf
42i8   // I8
42u32  // U32
3.14f32 // F32
```

---

### 5.4.3 运算符分派（比较 / 算术）

#### 分派原则

**OrdF64 / OrdI32 等：可比较类型的 Trait**

- **同类型**：直接分派到该类型对应的 Impl。
- **混合类型**：先提升到公共类型（5.4.4），再分派。

```morf
// 比较：要求两侧最终为同一具体类型 C，返回 Bool
x < y
// ~>
let C = InferCommonType{ typeof(x), typeof(y) }
Promote.To{ x, C }<OrdC>.Lt{ Promote.To{ y, C } }

// 算术：要求两侧最终为同一具体类型 C，返回 C
a + b
// ~>
let C = InferCommonType{ typeof(a), typeof(b) }
Promote.To{ a, C }<ArithC>.Add{ Promote.To{ b, C } }
```
+> 注：`<`, `>`, `<=`, `>=` 分派到 `OrdC`；`+`, `-`, `*`, `/` 分派到 `ArithC`。

---

### 5.4.4 类型提升

混合类型运算通过“提升”将两侧统一到**公共类型** `C`。

#### 公共类型规则

设 `C = InferCommonType{ T1, T2 }`，要求：

1. `T1` 与 `T2` 都可被提升为 `C`
2. `C` 是满足 (1) 的最小类型（尽量不扩大位宽/不引入浮点）

典型结果（非穷举）：

- `F64` 与任意 `Number`：`C = F64`
- `F32` 与整型：`C = F32`（可能损失精度）
- 有符号与无符号混合：选择能覆盖两者值域的最小有符号类型  
  例如：`I8 + U8 -> I16`，`I32 + U32 -> I64`
- 位宽扩展：`I8 + I16 -> I16`，`U8 + U16 -> U16`

#### 提升算子

```morf
// 标准库提供的提升工具
impl Promote for Number {
  // 将任意 Number 子类型提升到目标类型
  static To{ value: Number, target: Type } -> target {
    Switch {
      Case { value <: target, value },  // 已经兼容，无需转换
      Intrinsic.Convert{ value, target }
    }
  }
}
```

### 5.4.5 边界检查与溢出行为

#### 整数溢出策略

Morf 的整数运算默认采用**检查溢出（Checked）**模式：

```morf
let x: I8 = 127
let y = x + 1  // 运行时错误：I8 溢出
```

**可选的溢出模式**（通过 Impl 选择）：

1.  **Wrapping**（环绕）：`I8.Wrapping.Add{ 127, 1 } -> -128`
2.  **Saturating**（饱和）：`I8.Saturating.Add{ 127, 1 } -> 127`
3.  **Unchecked**（未检查，用于性能关键路径）：`I8.Unchecked.Add{ 127, 1 }` 行为未定义

#### 浮点特殊值

F64/F32 遵循 IEEE 754 标准，支持：

* **Infinity**：`F64.Infinity`, `F64.NegInfinity`
* **NaN**：`F64.NaN`

```morf
1.0 / 0.0  // -> F64.Infinity
0.0 / 0.0  // -> F64.NaN

F64.NaN == F64.NaN  // -> False（遵循 IEEE 754）
```

---

### 5.4.6 类型转换 API

#### 显式转换

```morf
// 标准库提供的转换工具
impl Convert for Number {
  static ToI32{ value: Number } -> (I32 | None) {
    Switch {
      Case {
        value <: IntervalCC{ I32.Min, I32.Max },
        Intrinsic.ConvertToI32{ value } 
      },
      None  // 超出范围返回 None
    }
  }
  
  static ToF64{ value: Number } -> F64 {
    Intrinsic.ConvertToF64{ value }  // 总是成功，但可能损失精度
  }
  
  // 其他类型的转换方法...
}
```

### 5.4.7 与 Interval 系统的集成

具体数字类型与 Interval 系统无缝集成：

```morf
// 区间约束自动推断具体类型
let positive_i32 = Gt{0} & I32
// 等价于 I32 & IntervalOO{ 0, I32.Max }

let byte_range = IntervalCC{ 0, 255 } & I32
// 类型检查器知道这个值可以安全转换为 U8

// 在函数签名中使用
let safe_div = (a: I32, b: I32 & ~{0}) -> I32 {
  a / b  // 编译器知道 b 不为 0，可以优化掉除零检查
}
```


---

## 6. 序列系统

Morf 的序列模型构建在构体与数字系统之上。Morf 中的序列本质上是**定长**的。通过对 `length` 属性施加不同强度的数值约束，可以定义不同长度范围的序列类型，但其实例在运行时长度始终是固定的。

### 6.1 元组 (Tuple)

元组是 Morf 中最基础的序列结构。

* **定义**: 包含数值索引属性，且 `length` 属性为 **Number** 的构体。
* **结构示例**:
    ```morf
    let T = [A, B]
    // 展开等价于
    let T = {
      __nominal__: TupleTag,
      length: 2,         // 长度是精确的 2
      0: A,
      1: B
    }
    ```
* **不变性**:
  *   由于 `2` 和 `3` 是互斥的 (`2 & 3 -> Never`)。
  *   因此 `[A, B]` (len=2) 和 `[A, B, C]` (len=3) 互斥，不存在子类型关系。
  * **结论**：定长元组天然避免了协变/逆变带来的类型安全问题。

### 6.2 字符串 (String)

字符串在 Morf 中被视为 **原子值**，但对外提供类似只读元组的行为。

#### 6.2.1 定义与类型

* **原子性**: 字符串是 Unicode 码点（Code Point）的序列。在值层面，它是不可分割的原子实体，不是由更小的对象组合而成的。
* **类型层次**:
  * **String**: 所有字符串值的父类型。
  * **字面量类型**: 每一个具体的字符串字面量（如 `"hello"`）都是一个独立的单例类型。
  * **互斥性**: 不同的字符串字面量类型是互斥的。`"a" & "b" -> Never`。

#### 6.2.2 虚拟投影

尽管字符串是原子的，但在进行属性访问时，系统将其投影为一个**只读元组**。

* **Length**: 具有 `length` 属性，值为字符串的字符数（Code Point 数量）。
* **索引访问**: 支持通过数字索引访问特定位置的字符。
  *   Morf **不区分字符（Char）与字符串**。`s[i]` 的返回值仍然是一个 `String` 类型，其长度为 1。
  *   越界访问返回 `None`。

```morf
let s = "Morf"

// 长度
s.length     // 4

// 索引
s[0]         // "M" (String 类型)
s[99]        // None

// 结构化视角
// "Morf" ≅ {
//   length: 4,
//   0: "M", 1: "o", 2: "r", 3: "f",
//   [...Number]: None
// }
```

#### 6.2.3 字符串拼接

虽然序列不支持变长修改，但可以通过 `+` 运算符连接两个字符串生成新的字符串值（见 3.6 节）。
---


## 7. 递归与不动点

Morf 支持结构化递归，允许定义无限深度的类型结构（如链表、树），但严格区分“结构构造”与“数值/逻辑计算”。

### 7.1 核心原则

1.  **结构递归**: 
    允许。当一个 Morph 的属性指向自身，或者通过 Union 间接指向自身时，系统视为合法的“无限构体”。
  * *语义*: 它是懒加载的 (Lazy)，只有在访问具体属性时才会展开。
  * *与 None 的交互*: 若递归路径上的某节点计算结果为 `None`，根据 None 的传染性，整个递归访问路径将坍缩为 `None`。
2.  **计算递归**: 
    禁止。在表达式求值（如 `a + b`）或函数逻辑中出现的无终止循环将导致系统坍缩。
  * *语义*: 这种循环在逻辑上等价于无法到达终点，因此求值结果为 `Never`（底空间）。

### 7.2 等价性与子类型

#### 7.2.1 递归等价性

Morf 采用 **Equi-recursive（等递归）** 语义。这意味着只要展开后的无限树结构同构，两个递归类型即视为定义等价（`≡`）。

*   类型名本身不参与等价性判定，仅作为结构的别名。
*   例：若 `A = { next: A | None }` 且 `B = { next: B | None }`，则 `A ≡ B`。

#### 7.2.2 共归纳子类型

在判定两个递归类型的子类型关系（`RecA <: RecB`）时，实现必须采用**共归纳（Co-inductive）**或**假定-验证（Assume-Guarantee）**算法，以确保判定过程终止。

* **原则**：在判定过程中，若遇到正在判定的目标 `RecA <: RecB`（即检测到循环依赖），则直接假定该关系成立（返回 `true`），并继续验证其他分支。若所有分支验证均通过，则该假设最终成立。

### 7.3 实现建议：打结法

为了在保持不可变性和驻留的前提下支持递归（即实现 3.15 定义的变量提升语义），推荐采用“打结”算法。

#### 7.3.1 占位符与路由
1.  **检测 Pending**: 在求值表达式时，若遇到对 **Pending** 状态变量（如 `A`）的引用，不立即报错，而是检查当前操作是否属于“结构性引用”。
2.  **创建入口**: 若是结构性引用，创建一个 **`RecursiveRef` (递归引用)** 节点。该节点仅包含一个指向 `A` 最终地址的“入口”（此时该地址尚未填充）。
3.  **延迟绑定**: `{ next: Ref(A) }` 的 Hash 计算应包含其结构的“构体”而不包含 `Ref(A)` 的具体值，或者使用特殊的循环 Hash 算法。

#### 7.3.2 打结过程
1.  **构造构体**: 完成 Morph 的初步构造。
2.  **转正**: `let A = ...` 执行完毕后，将 `A` 标记为 **Resolved**，并分配最终的内存地址。
3.  **回填**: 扫描当前作用域内所有指向 `A` 的 `RecursiveRef`，将其内部指针更新为 `A` 的真实地址。
4.  **化简**: `A & A` 在递归层面上应能识别出它们是同一个“结”，从而避免无限展开。

### 7.4 示例与推导

#### 7.4.1 链表定义
```javascript
// 定义 List 为：要么是 End，要么是 Node 且 next 指向 List
// 使用前缀 | 语法，类似 TypeScript (注意: 无需逗号分隔)
let List = 
  | { kind: "End" }
  | { kind: "Node", next: List } 
```
* **推导**: 系统识别出 `List` 在定义中引用了自身。内部表示为 `End | { Node, next: Ref(List) }`。
* **合法性**: 这是一个合法的结构递归。

#### 7.4.2 别名循环
```javascript
let A = B
let B = A
```
* **结论**: 没有任何构造器（Morph `{}`）介入。这种纯粹的别名循环导致符号解析死锁，系统无法确定其结构，判定为 **`Never`**。

#### 7.4.3 计算循环
```javascript
let Num = Num - 1
```
* **结论**: 减法运算需要立即求出 `Num` 的数值。由于 `Num` 处于 "Pending" 状态且未被构造器包裹，无法进行数值运算，直接返回 **`Never`**。

---

## 8. 可变状态与引用系统

Morf 引入了 **"一等公民槽位"** 模型。这一设计旨在弥合纯函数式编程（不可变数据）与命令式编程（状态变化）之间的鸿沟，同时避免引入额外的 `Ref` 对象包装器。

### 8.1 核心模型：变量即槽位

* **`let`**: 创建一个值的直接绑定（不可变）。在作用域内不可重绑定。其类型行为遵循 3.14.1 定义的精确类型原则。
* **`mut`**: 创建一个可变的 **变量槽**。

#### 8.1.1 Mut 绑定的类型语义

与 `let` 不同，`mut` 绑定引入了显式的存储槽位，因此支持类型宽化。

*   **推导类型**: `mut x = Expr`
    *   **语义**: 创建一个槽位，其初始值为 `Expr`。
    *   **类型**: 槽位的类型默认为 `Expr` 的类型（若是字面量则推导为基础类型，如 `I32` 或 `String`，而非单例）。

*   **显式类型**: `mut x: T = Expr`
    *   **语义**: 创建一个约束为 `T` 的槽位。
    *   **类型宽化**: 无论 `Expr` 的具体类型多么精确（如 `{ a: 1 }`），变量 `x` 在后续读取时的静态类型**被宽化为 `T`**（如 `{ a: Number }`）。
    *   **赋值约束**: 后续对 `x` 的赋值 `x = NewVal` 必须满足 `Type(NewVal) <: T`。

`Mut` 实际上也是一个构体。可以通过 `Mut { T }` 定义类型，也可以通过 `mut T` 定义（简写）。

当声明 `mut a = 1` 时，编译器在底层构建了一个隐式的构体，其逻辑结构类似于：
```morf
// 概念模型，非真实语法
let $slot_a = { value: 1 }
```

> **建议**：如果在定义构体类型时，某个属性预期是可变的（即后续会对该属性进行赋值更新），应当（SHOULD）使用 `{ key: mut Type }` 的语法进行显式标注。虽然底层更新机制可能基于 Copy-on-Write，但这能清晰传达设计意图。

### 8.2 自动解引用

为了保证语法的简洁性，Morf 在普通表达式中对 `mut` 变量进行自动拆箱。

* **读取**: `let b = a + 1`。编译器自动将其转换为 `$slot_a.value + 1`。
* **取址**: `let r = &a`。使用 `&` 运算符获取 `$slot_a` 本身（见 3.13）。
* **赋值**: `a = 2`。编译器自动将其转换为 `$slot_a.value = 2`。
* **快照传递**: 当 `mut` 变量传递给**非 mut** 参数时，传递的是其当前值的快照。

```morf
let LogVal = (v) { Log{v} }

mut x = 1
LogVal(x) // 传递的是 1 (Copy)，而非 x 的槽位
```

### 8.3 引用传递

为了在函数间共享状态（例如异步更新或原地修改），函数参数可以显式标记为 `mut`。这实现了类似于“引用传递”的效果。

* **语法**: `f: (target: mut Number) { ... }`
* **语义**: 此时传递的不再是值的快照，而是 **Slot 本身**。
* **效果**: 函数内部对 `target` 的赋值会直接更新外部的 Slot。

示例：
```morf
let AsyncInc = (target: mut Number) {
  // target 引用了外部的 Slot
  TimeOut(1000, () {
    target += 1 
  })
}

mut a = 1
AsyncInc(a) // a 变为 2
```

### 8.4 结构化更新

由于 Morf 的基础类型是不可变的，对 `mut` 变量的属性更新遵循 **"Copy-on-Write"** 语义的变体。

* **语法**: `obj.prop = val`
* **语义**: 等价于 `obj = Update(obj, "prop", val)`。
* **底层行为**:
    1.  创建一个包含新属性值的新 Morph。
    2.  将 `mut` 变量槽指向这个新地址。
    3.  利用结构共享优化内存开销。

这确保了即便引入了可变性，每次赋值操作产生的都是一个新的、合法的不可变快照，从而天然支持时间旅行调试。

#### 8.4.1 编译期优化：原地更新

尽管语义上每次更新都产生新对象，但为了保证性能，实现应当进行**唯一引用分析** 或 **引用计数检查**。

* **原则**: 若编译器或运行时能证明在执行 `obj.prop = val` 时，原对象 `obj` **没有其他活跃的引用**（即当前持有的是唯一引用），则实现**可以**（且应当）将其优化为底层的**原地修改**。
* **透明性**: 这种优化必须对用户透明。即无论底层是否进行了原地修改，程序的观测行为（如相等性判断结果）必须与“总是创建新对象”的语义一致。

### 8.5 流敏感分析

为了在结构化类型系统中安全地使用 `mut`，编译器对 `mut` 变量实施 **SSA (Static Single Assignment)** 变换与流敏感分析。

这意味着同一个 `mut` 变量在不同的代码路径下可以拥有不同的、更精确的类型（Type Narrowing）。

```morf
mut x = Number | String  // x 类型宽泛

Switch {
  Case {
    Type.IsNum{x},
    {
      // 在此块中，x 被细化为 Number
      // 编译器允许数学运算
      x += 1 
    }
  },
  // 在此块中，x 被细化为 String
  Log{ "String: " + x }
}
```

### 8.6 确定性资源管理 (RAII)

对于文件句柄、网络连接等非内存资源，依赖 GC 进行回收是不确定的。Morf 引入 `Disposable` 模式来支持确定性的资源释放。

#### 8.6.1 Disposable 协议

若一个 Impl 实现了 `Disposable` 接口（定义了 `Dispose` 方法），则该对象被视为需要显式清理的资源。

#### 8.6.2 Using 作用域

Morf 不提供特殊的 `try-with-resources` 语法，而是通过标准库函数 `Using` 实现：

```morf
// 打开文件，确保在块结束时关闭
Using{ File.Open{"data.txt"}, (file) {
  file.ReadLines{}
}} 
// 此处 file.Dispose{} 已被自动调用
```

### 8.7 高级内存控制：Unique 与 Arena

为了满足系统级编程或高性能场景的需求，Morf 允许高级用户通过**线性类型（Linear Types）**或**区域内存（Regions）**来绕过 GC 机制。

#### 8.7.1 线性类型 (Unique)

`Unique{T}` 是一个特殊的类型包装器，它向编译器传达以下约束：
1.  **唯一所有权**: 该值在同一时刻只能有一个引用。
2.  **禁止复制**: 赋值或传参操作会发生**移动 (Move)**，原变量失效。
3.  **立即释放**: 当 `Unique` 对象离开作用域且未被移动时，系统**立即**回收其内存（不经过 GC）。

```morf
// 创建一个由 Unique 管理的对象
let ptr = Unique.New{ { x: 1, y: 2 } }

let process = (p: Unique) { ... }

process{ ptr } // 所有权转移给 process
// Log{ ptr }  // 编译错误！ptr 已被移动
```

#### 8.7.2 区域内存 (Arena)

对于大量产生且生命周期一致的小对象（如游戏实体、请求级上下文），可以使用 `Arena` 进行批量管理。

*   `Arena` 内分配的对象不进行独立的 GC 追踪。
*   当 `Arena` 销毁时，其内部所有对象一次性释放。

### 8.8 垃圾回收与内存模型

Morf 运行时必须实现自动内存管理。考虑到 Morf "默认不可变、局部可变" 的语言特性，规范建议实现采用 **分代式垃圾回收 (Generational Garbage Collection)** 策略。

#### 8.8.1 分代假设

基于 "大部分对象朝生夕死" 的弱分代假设，堆内存被划分为：

1.  **新生代 (Young Generation / Nursery)**:
  *   新对象在此通过指针碰撞 (Bump Allocation) 极速分配。
  *   回收时采用 **Copying GC**，存活对象晋升至老年代。
2.  **老年代 (Old Generation)**:
  *   存放长生命周期对象。
  *   回收时采用 **Mark-Sweep** 或 **Mark-Compact**。

#### 8.8.2 不可变性对 GC 的优化

Morf 的不可变特性天然利于分代 GC：

* **老年代引用新生代**：在纯不可变数据中，老对象不可能指向新对象（新对象创建时老对象已存在且不可变）。
* **写屏障 (Write Barrier)**：仅需监控 `mut` 槽位 (Slot) 的更新。只有当 `mut` 变量（位于老年代）被更新为指向新生代对象时，才需记录到 **记忆集 (Remembered Set)**。这极大降低了屏障开销。

---

## 9. Effect 传播与坍缩

支持编译时展开并保证副作用的可预测性。

#### 9.1 核心定义

* **Effect**: 一个名义符号，表示某种非纯粹的计算行为。
* **Effect 集合 ($\epsilon$)**: 一个表达式在求值过程中可能触发的所有 Effect 的并集。
* **固有效应 (`intrinsic_effect`)**: 对任意可调用值 `f`，`f.intrinsic_effect` 是“一次调用 `f{...}` 在其函数体内部可能触发的 Effect 集合”。  
  * **用户函数**：若 `let f = (...) { E }`，则定义 `ε(f) = None`，且 `f.intrinsic_effect = ε(E)`。  
  * **宿主 primitive**：其 `intrinsic_effect` 由宿主环境在定义处显式标注（例如 `Sys.IO.Write` 具有 `Effect.IO`）。
* **纯粹性**: 若 $\epsilon(E) = \text{None}$，则称表达式 $E$ 是纯的。


#### 9.2 Effect 的源头

系统中存在两类原子级的 Effect 源头：

1.  **状态源**:
  *   对任何 `mut` 槽位的读取（Read）或写入（Write）操作，自动被赋予 `Effect.State`。
  * *注：若分析器能证明 `mut` 变量未逃逸出当前闭合块且不影响外部环境，可进行纯化优化。*
2.  **原生源**:
  *   由宿主环境提供的 primitive 函数（如 `Sys.IO.Write`, `Sys.Time.Now`）带有特定的名义 Effect（如 `Effect.IO`）。

#### 9.3 传播规则

Effect 遵循“向上污染”的代数并集规则：

1.  **复合表达式**: $\epsilon(f\{a, b, \dots\}) = \epsilon(f) \cup \epsilon(a) \cup \epsilon(b) \dots \cup f.\text{intrinsic\_effect}$。
2.  **属性访问**: $\epsilon(obj.prop) = \epsilon(obj)$。
3.  **集合/元组构造**: $\epsilon([a, b]) = \epsilon(a) \cup \epsilon(b)$。构造本身是纯的，但其成员的求值可能带有 Effect。

这意味着如果 `List.map` 的回调函数 `f` 带有 `IO` Effect，那么 `List.map{list, f}` 整个表达式的 Effect 集合也将包含 `IO`。

#### 9.4 封印与坍缩

为了在含有副作用的系统中保留纯粹的片段，Morf 使用函数抽象和 `wrap` 来隔离 Effect。

1.  **函数定义 (Abstraction)**: 
  *   定义一个函数 `let F = () { E }` 是纯的操作。$\epsilon(F) = \text{None}$。
  *   内部的 Effect $\epsilon(E)$ 被“封印”在函数体中。
2.  **自动 Thunk (Wrap)**:
  *   `wrap { E }` 将表达式 $E$ 的 Effect 坍缩。`wrap` 表达式本身的结果是一个纯的 Morph（一个零参函数）。
3.  **解封 (Apply)**:
  *   当表达式发生调用（Apply）时，被封印的 Effect 释放并向上污染。对调用表达式 `f{a, b, ...}`，其 Effect 定义为：
        $$ \epsilon(f\{a,b,\dots\}) = \epsilon(f)\ \cup\ \epsilon(a)\ \cup\ \epsilon(b)\ \cup\ \dots\ \cup\ f.\text{intrinsic\_effect} $$
  *   特别地，若 `wrap { E }` 产生一个零参 thunk `t`，则 `t{}` 的 Effect 恰为 `t.intrinsic_effect`（并按上式传播到调用点）。

#### 9.5 编译展开准则

编译器根据 Effect 集合决定优化策略：

1.  **完全展开**: 若 $\epsilon(E) = \text{None}$ 且所有依赖项为常量，则进行常量折叠。
2.  **部分展开**:
  *   对于 Morph $\{ a: E_1, b: E_2 \}$，若 $E_1$ 是纯的而 $E_2$ 是有副作用的。
  *   编译器可以安全地预计算并将 `obj.a` 替换为结果值。
  *   `obj.b` 必须保留为原始调用，或仅在确定执行顺序的前提下进行展开。
3.  **副作用隔离**: 编译器禁止跨越有 Effect 的表达式进行指令重排，除非能证明两个 Effect 集合是正交的（Orthogonal）。

**正交 (Orthogonal) 的最小定义（保守）**：
- 称两个表达式 `A` 与 `B` 的 Effect 集合正交，当且仅当：$$ \epsilon(A) \cap \epsilon(B) = None $$ 且 `Effect.State ∉ (ε(A) ∪ ε(B))`。
- 实现据此可安全地在不改变可观测行为的前提下，对 `A` 与 `B` 进行重排；该定义是保守近似，未来可通过更精细的 Effect（如区分 Read/Write）放宽。

#### 9.6 静态优化策略总览

Morf 的静态优化建立在 **Effect 分析**、**类型与规范形**、**SSA/流敏感** 以及 **唯一引用分析** 之上。实现可按下述维度组织优化 pass。

| 优化类别 | 依据 / 触发条件 | 优化动作 |
|----------|-----------------|----------|
| **常量折叠** | $\epsilon(E) = \text{None}$ 且依赖均为常量（见 9.5） | 在编译期求值并替换为常量 |
| **部分求值** | Morph 构造中部分字段为纯表达式 | 预计算纯字段，仅保留有 Effect 的字段为延迟求值 |
| **指令重排** | 两表达式 Effect 正交（9.5） | 在不改变可观测行为下重排、并行化或向量化 |
| **mut 纯化** | mut 未逃逸出闭合块、不影响外部（9.2 注） | 将局部 mut 视为不可变，参与常量折叠或 CSE |
| **唯一引用 + CoW 优化** | 证明 `obj` 为唯一引用（8.4.1） | 将 `obj.prop = val` 优化为原地更新，减少分配 |
| **类型驱动** | 子类型 / 区间 / 单例类型已知 | 消除不可达分支、擦除运行时类型检查、优化除零等（如 5.4.7 的 `b: I32 & ~{0}`） |
| **Impl 静态分派** | 接收者类型为单例或封闭 DiSet，且无动态 handle 覆盖 | 将 `E.Method{...}` 脱糖为直接调用，消除虚表查找 |
| **内联与去 Thunk** | 小函数或 wrap 参数在单点调用 | 内联函数体；对单次调用的 wrap 直接内联 thunk 体，避免闭包分配 |

**类型层优化**：类型逻辑层的规范形归约（2.1.2）、DiSet/ConSet 扁平化（2.3.7）与键投影（2.2.2）在编译期完成。可利用其结论做：单例键访问的精确类型（3.4.5）、区间约束下的数值特化、以及 `Never` 分支消除。

**Impl 与名义**：候选集限定于具名空间/DiSet{具名, None}（10.3.2），且脱糖规则固定（10.3.3）。在无动态 `handle` 的上下文、且接收者类型可静态确定时，可将 `.` 调用完全解析为静态调用，便于内联与去虚拟化。

**建议实现顺序**：先实现 Effect 传播与 9.5 的展开/重排规则，再叠加 SSA（8.5）、类型细化与常量折叠，最后在稳定 IR 上做唯一引用分析与 Impl 静态分派。

---

## 10. Impl 系统

Morf 中的 “方法”，是由 **Impl 构体** 提供的一组函数定义，并通过统一的 **点号 (`.`)** 语法，在表达式层面被脱糖与分派。

本章规范定义：

- `impl` 声明会产生什么构体结构；
- `.` 符号的统一查找规则（Data > Impl）；
- `<impl_id>.` 的显式指定规则；
- `extends`/`super` 的覆盖与继承规则；
- 当存在多个候选实现时的选择规则（later-wins）。

### 10.1 Impl 也是构体

Impl 的本质是一个被特殊标记的构体，因此它可以通过变量绑定的方式进行定义。

#### 10.1.1 Impl 表达式

Morf 支持 `impl for T { ... }` 表达式，该表达式求值后返回一个“匿名 Impl 构体”。通常我们将其绑定到一个变量上以供后续引用（如 `.` 查找）。

* **语法**：
  ```morf
  let ImplName = impl TargetType {
      Method: (self) { ... }
  }
  // 也可以显式加上 for 关键字
  // let ImplName = impl for TargetType { ... }
  ```

* **语法糖（声明式写法）**：
  为了兼容习惯，也支持声明式写法，其语义等价于上述 `let` 绑定：
  ```morf
  impl ImplName for TargetType { ... }
  // 等价于
  let ImplName = impl TargetType { ... }
  ```

* **匿名用法**：
  Impl 表达式可以直接用于 `handle` 或作为值传递，无需命名。
  ```morf
  handle impl Uni { ... } with {
      // ...
  }
  ```

#### 10.1.2 Impl 的名义标记
为了使“这是一个 impl”这一事实可被系统可靠识别，impl 构体必须携带名义标记。其可以这样表示：

```morf
AnotherImpls
// { [NominalKey]: DiSet{ ImplNominal, AnotherImplsNominal }, foo: ... }
```

因此本规范约束：

- 任意 `impl X ...` 产生的构体 `X`，其 `[NominalKey]` 必须包含 `ImplNominal`。
- 同时 `[NominalKey]` 必须包含一个该 impl 自身的名义符号（如 `AnotherImplsNominal`），用于稳定标识该实现体。

> 注：这里的“包含”使用集合语义（`DiSet{...}`）表达；具体存储形式由实现决定，但必须可判定等价。

#### 10.1.3 方法修饰符：static

在 impl 内部定义方法时，可以使用 `static` 关键字进行修饰：

- **普通方法 (Ordinary Method)**：默认状态。期望在调用时接收“调用者（Subject）”作为第一个参数（即 `self`）。
- **静态方法 (Static Method)**：使用 `static` 修饰。在调用时**不接收**调用者，仅利用 Impl 机制进行上下文查找。

> **建议**：静态方法应当（SHOULD）使用首字母大写的命名风格（PascalCase），例如 `Create`, `From`；以便于在调用点与普通方法（camelCase）进行视觉区分。

---

### 10.2 `impl ... for T`：目标类型与适用性

`impl X for T { ... }` 中的 `T` 被称为该 impl 的 **目标类型**。

给定某个 `self` 值/类型 `S`，称 `X` 对 `S` **适用**，当且仅当：

- $ S <: T $

（即 `self` 的类型是 `T` 的子类型。）

示例：

```morf
impl TreeImpls for (Tree | None) { ... }
```

则 `TreeImpls` 对 `Tree` 与 `None` 均适用。

---

### 10.3 统一调用语法 (.) 与查找范围

#### 10.3.1 统一访问规则

表达式 `E.Key` 的解析遵循 **"Data 优先，动态 Impl 其次，静态 Impl 兜底"** 的原则。

查找步骤如下：

1.  **Data 查找**:
  *   检查 `E` 本身是否拥有名为 `Key` 的属性。
  *   若存在 -> 返回 `E[Key]` (直接属性访问)。
  * **优先级**: 数据的 Key 永远高于 impl 的方法名称。这意味着如果数据中存在与方法同名的属性，方法将被“遮蔽”。

2.  **动态 Impl 查找 (Dynamic Context)**:
  *   若 Data 查找失败，则在当前调用栈的 **动态 Impl 上下文** 中查找。
  *   实现必须从栈顶向下搜索最近的 `using impl` 作用域。
  *   若命中 -> 脱糖调用。

3.  **静态 Impl 查找 (Static Context)**:
  *   若动态查找失败，则在 **适用 Impl 候选集** 中查找名为 `Key` 的方法。
  *   若命中实现 `I` 中的方法 `M` -> 根据 `M` 的修饰符进行脱糖调用（见 10.3.3）。
  *   若未命中 -> 返回 `None` (或报错，视具体语境)。

#### 10.3.2 Impl 候选集合

Impl 查找 **仅允许**在以下候选集合中进行：

1. **`impl for 具名空间`**：目标类型为某个具名空间的 impl；
2. **`impl for DiSet{ 具名空间, None }`**：目标类型为 `DiSet{N, None}`（即 `N | None`）这一类形态的 impl；
3. **`impl` 构体自身**：即候选必须是带有 `ImplNominal` 标记的构体。

超出以上范围的 `impl`（例如纯结构目标类型 `for { value: Uni }`）**不得**被 `.` 直接自动命中；必须使用 `<impl_id>.` 显式指定（见 10.4）。

> 直观上：隐式查找只服务于“以具名空间为中心的 impl 体系”，避免结构匹配导致的开放世界歧义与不可预期分派。

#### 10.3.3 Impl 命中的脱糖语义

若 `E.Method{ args }` 通过 Impl 查找命中实现 `X`，则采取以下脱糖规则：

1.  **普通方法**：
  *   脱糖为：`X.Method{ E, args }`
  *   语义：`E` 被作为第一个位置参数（`self`）注入。这是最常见的“实例方法”行为。

2.  **静态方法** (`static`)：
  *   脱糖为：`X.Method{ args }`
  *   语义：`E` 仅作为**寻址锚点**（用于在上下文查找中命中实现 `X`），随后**被丢弃**，不参与参数传递。

---

### 10.4 `<impl_id>.` 与 `<impl_id>[]`：显式指定实现

当满足下列任一条件时，必须使用显式形式：

- 发生了名称冲突（Data 遮蔽了 Method），需要强制调用 Method；
- 候选范围内找不到适用实现；
- 存在你希望使用但不在允许范围内的实现（例如纯结构目标类型的 impl）；
- 或者你希望绕过默认选择规则，强制指定某个实现体。

#### 10.4.1 显式调用语法

* **点号形式**: `E<ImplId>.Method{ args }`
* **方括号形式**: `E<ImplId>[keyExpr]{ args }`

**规范性脱糖**：

两种形式都脱糖为相同的语义：
- `ImplId.Method{ E, args }` 或 `ImplId[keyExpr]{ E, args }`

#### 10.4.2 点号形式示例

```morf
impl AnotherImpls for { value: Uni } {
  foo: (self) { self.value }
}

let t = { value: 1, foo: "data" }

// 1. t.foo -> "data" (Data 优先)
// 2. Impl for 结构类型不能被直接命中

// 使用显式语法调用 Impl
t<AnotherImpls>.foo{} // 1
// 等价于
AnotherImpls.foo{ t } // 1
```

#### 10.4.3 方括号形式示例

方括号形式适用于动态方法名或非标识符键。

```morf
impl StringOps for String {
  reverse: (self) { ... }
}

let s = "hello"
let methodName = "reverse"

// 方括号形式：动态方法名
s<StringOps>[methodName]{}       // 使用 StringOps.reverse
s<StringOps>.reverse{}           // 等价，但方法名是静态的
```

---

### 10.5 `extends` 与覆盖

#### 10.5.1 Impl 继承

`impl Child extends Parent { ... }` 声明 `Child` 继承 `Parent` 的方法集合，并允许对同名条目进行覆盖。

```morf
impl HyperTreeImpls extends TreeImpls {
  Invert: (self) { ... }
}
```

#### 10.5.2 覆盖规则

在同一条方法名 `Method` 上，如果 `Child` 与 `Parent` 均提供实现，则 `Child.Method` 覆盖 `Parent.Method`。

由于 Morf 中“数据就是类型”，因此 impl 本身也处于类型关系与构体结构之中；**签名一致**的覆盖是合法的语言行为。

#### 10.5.3 `super` 语义

在 `Child` 的方法体内部，`super.Method{ ... }` 表示调用被覆盖的父级实现（按继承链向上解析到最近的一个定义点）。

示例：

```morf
impl HyperTreeImpls extends TreeImpls {
  Invert: (self) {
    Console.log("HyperTreeImpls.Invert")
    super.Invert{}
  }
}
```

---

### 10.6 同名方法的选择规则（默认分派）

当表达式 `E.Method{...}` 在允许的候选范围内存在多个“适用实现”时，本规范采用以下选择规则：

- **later-wins（后来者优先）**：若同时存在多个 impl 都定义了 `Method`，则选择“后出现/后生效”的实现体。

该规则与示例断言一致：

```morf
// 如果同时有两个 impl 都定义了 Invert，那么应该使用后来者的实现
let inv = t.Invert{}
```

> 注：何谓“后出现/后生效”由实现的可观测机制定义（例如：同一作用域内的声明顺序、模块加载顺序、或显式导入顺序）。但实现必须保证：给定同一程序与同一加载顺序，分派结果是确定的。

---

### 10.7 动态 Impl 与上下文注入

Morf 支持在运行时动态替换 Impl 的实现，这一机制被称为 **动态 Impl**。它将 Impl 系统从单纯的静态多态扩展为 **代数效应 (Algebraic Effects)** 和 **依赖注入 (Dependency Injection)** 的统一模型。

#### 10.7.1 语法：`handle ... with`

为了简化上下文注入的语法，Morf 引入 `handle` 关键字（意为“处理接口请求”或“提供能力实现”）。

* **语法**: `handle Interface with Implementation { Block }`
* **匿名对象简写**: `handle Interface with { ...methods } { Block }`
  *   当 `with` 后跟随一个对象字面量时，编译器会自动将其视为“实现了 Interface 目标类型的匿名 Impl”。

* **语义**: 
    1.  在 `Block` 的执行期间（包括其调用的所有子函数），任何对 `Interface` 的方法查找都将优先分派给 `Implementation`。
    2.  这种替换是 **动态作用域 (Dynamic Scoped)** 的，即它影响当前的调用栈。
    3.  当 `Block` 执行结束，Impl 环境自动恢复。

#### 10.7.2 示例：依赖注入

`handle` 允许在不修改函数签名的情况下传递上下文依赖，且语法非常接近自然语言。

```morf
// 定义接口 (Effect)
let Logger = impl Uni {
  log: (msg) { Sys.Print{ msg } } // 默认实现
}

// 业务函数 (无需传递 logger 参数)
let worker = (data) {
  Uni<Logger>.log{ "Processing..." }
}

let main = () {
  // 1. 使用默认 Logger
  worker{ "A" }

  // 2. 注入已有实现
  let FileLogger = impl Uni {
      log: (msg) { File.Append{ "log.txt", msg } }
  }
  handle Logger with FileLogger {
    worker{ "B" }
  }

  // 3. 注入匿名实现 (类似 extend/override)
  handle Logger with {
    log: (msg) { Sys.Print{ "[MOCK] " + msg } }
  } {
    worker{ "C" }
  }
}
```

#### 10.7.3 用途：代数效应与控制流

配合 `wrap` (Thunk) 机制，动态 Impl 可以实现复杂的控制流，如异常、生成器、协程等。

* **Continuation (Resume)**: 
    *   虽然 Morf 0.3 暂未暴露显式的 `resume` 原语，但用户可以通过在 Impl 方法中抛出特定的控制流信号（或返回特定的控制流对象），并在 `using impl` 边界处进行处理，来模拟效应处理程序 (Effect Handler)。
    *   未来的 Morf 版本可能引入原生的一次性延续 (One-shot Continuation)。

---



## 11. 异步系统

Morf 的异步模型建立在 **Effect 系统** 与 **轻量级线程 (Fiber)** 之上。其设计目标是消除“函数染色问题”，让异步代码像同步代码一样直观，同时提供强大的并发控制能力。

### 11.1 核心概念

#### 11.1.1 Effect.Async

*   **定义**: `Effect.Async` 是一个系统内置的 Effect。
*   **源头**: 所有涉及耗时操作（IO、Timer 等）的宿主原语（如 `Sys.Net.Fetch`）都带有 `Effect.Async`。
*   **传播**: 任何调用了异步函数的函数，其 `intrinsic_effect` 都会自动染上 `Effect.Async`。
*   **调度**: 当在同步上下文调用带有 `Effect.Async` 的函数时，编译器会自动插入调度点：挂起当前 Fiber，直到操作完成，然后恢复执行。

#### 11.1.2 Future (Task)

*   **定义**: `Future{T}` 是一个代表“正在进行的计算”的句柄（Handle）。
*   **热启动**: Future 在创建时即开始执行（Hot Future）。
*   **封装**: `Future` 对象本身**不带有** `Effect.Async`。这意味着获取一个 Future 是纯粹的、非阻塞的操作。

### 11.2 关键字

#### 11.2.1 `async`

*   **语法**: `async Expr`
*   **约束**: `Expr` 必须是一个函数调用或代码块。
*   **语义**: 
    1.  创建一个新的 Fiber。
    2.  在该 Fiber 中并发执行 `Expr`。
    3.  立即返回一个指向该 Fiber 结果的 `Future{T}`。
    4.  **切断 Effect**: 即使 `Expr` 带有 `Effect.Async`，`async Expr` 表达式本身也没有 `Effect.Async`。这允许在不阻塞当前线程的情况下启动后台任务。

#### 11.2.2 `await`

*   **语法**: `await Expr`
*   **约束**: `Expr` 的类型必须是 `Future{T}`。
*   **语义**:
    1.  挂起当前 Fiber。
    2.  等待目标 `Future` 完成。
    3.  返回 `Future` 的结果 `T`。
    4.  **释放 Effect**: `await` 表达式带有 `Effect.Async`。

### 11.3 编程模式对比

#### 11.3.1 串行（默认风格）

```morf
// 看起来是同步的，实际上底层是异步调度的
let data1 = fetch{ "http://a.com" } 
let data2 = fetch{ "http://b.com" } // 等待 data1 完成后才开始
```

#### 11.3.2 并行（优化风格）

```morf
// 使用 async 显式并发
let task1 = async fetch{ "http://a.com" } 
let task2 = async fetch{ "http://b.com" } 

// 此时两个请求都在后台跑

// 在需要结果时汇合
let res1 = await task1
let res2 = await task2
```

### 11.4 标准库支持

关于 `Future` 类型及 `Async` 工具集的详细 API 定义，请参阅 **11.9 异步与并发**。


---

## 12. 标准库

Morf 标准库采用 **“类型根 + 后台实现”** 的组织范式：

- **类型根 `X`**：一个具名空间，作为该概念的父类型入口。
- **实现 `XxxImpl`**：一个或多个 `impl` 构体，为类型根提供方法与工具函数。

### 12.1 核心全集

定义在全局作用域的基元。

* **Uni**: `{}`。全集，所有类型的父类型。也常写作 `Any`。
* **None**: 递归的空值。表示值的缺失。
* **Proof**: `~None`。实存值。表示除 None 以外的所有值。
* **Never**: 逻辑矛盾。底空间。
* **Function**: 所有函数值的父类型。
  *   `impl FunctionImpl for Function` 提供 `Apply`, `Bind` 等基础能力。
* **Type**: 所有“类型值”的父类型（在 Morf 中，类型即值，通常指代用于描述类型的构体）。

### 12.2 流程控制

* **Switch{ wrap ...branches }**: 多路分支。最后一个分支是默认值。
* **Match{ cond, wrap do }**: 分支项。
* **If{ cond, wrap then, wrap else }**: 双路分支。
* **While{ cond, wrap body }**
* **Loop{ cond, wrap body }**
* **Iter{ cond, body }**
* **Signal**: 控制流信号操作与原语。
  * **static Emit{ tag: Nominal, payload: Any }: Never**: 发射信号，中断当前流并向上逃逸。
  * **static Handle{ wrap block, handlers }: Any**: 执行 `block` 并捕获其中发射的信号。
    * `handlers` 是一个映射 `{ [SignalTag]: (payload) -> Result }`。
  * **ReturnTag**: (名义符号) 返回信号标识。
  * **BreakTag**: (名义符号) 中断信号标识。
  * **ContinueTag**: (名义符号) 继续信号标识。

### 12.3 数字模块

* **Interval**: (类型根) 所有区间的父类型。
* **impl IntervalImpl for Interval**: (工具集)
  * **static Lt{ n }**:返回类型 `Lt{n}`。
  * **static Gt{ n }**:返回类型 `Gt{n}`。
  * **static OO{ min, max }**: 返回 $(min, max)$。
  * **static OC{ min, max }**: 返回 $(min, max]$。
  * **static CO{ min, max }**: 返回 $[min, max)$。
  * **static CC{ min, max }**: 返回 $[min, max]$。

* **Number**: 所有数值的父类型。其父类型是 `Interval`。
  *   具体类型：`Float` (`F32`, `F64`), `Integer` (`I8`-`I64`, `U8`-`U64`)。
* **impl NumberOps for Number**:
  *   提供了 `Abs`, `Ceil`, `Floor`, `Round`, `Sqrt`, `Pow` 等通用数学方法。
  *   提供了 `ToString`, `ToInt`, `ToFloat` 等转换方法。

### 12.4 序列与集合

* **Seq**: 所有序列（Tuple / String 投影 / Array）的父类型。
* **impl SeqImpl for Seq**:
  * **length**: (属性) 序列长度。
  * **static Of{ ...items }: Seq**: 构造序列。
  * **get{ index }: T | None**: 安全索引访问。
  * **head{}: T | None**: 取首元素。
  * **tail{}: Seq**: 取除去首元素后的剩余部分。
  * **map{ f: (T)->U }: Seq**: 映射。
  * **filter{ pred: (T)->Bool }: Seq**: 过滤。
  * **reduce{ init, f }**: 归约。
  * **slice{ start, end }**: 切片。
  * **concat{ other }**: 连接。
  * **push{ item }**: 返回追加元素后的新序列。
  * **join{ separator }: String**: 连接为字符串。
  * **startsWith{ prefix }**: 前缀检查。
  * **endsWith{ suffix }**: 后缀检查。
  * **contains{ sub }**: 包含检查。
  * **split{ sep }: Seq**: 分割。

* **String**: 字符串类型（值类型）。
* **impl StringOps for String**:
  * **length**: 字符数。
  * **trim{}**: 去除首尾空白。

* **List**: 链表或动态数组结构（通常作为递归结构实现）。
* **impl ListImpl for List**: 提供类似 `Seq` 的操作，但针对递归结构优化。

### 12.5 错误处理

* **Option**: 表示可能存在的值。
  *   定义: `Option = (T) { T | None }`。
* **impl OptionImpl for Option**:
  * **isSome{}**: 返回 Bool。
  * **unwrapOr{ default }**: 取值或默认。
  * **map{ f }**: 若为 Some 则映射，否则返回 None。

* **Result**: 表示操作成功或失败。
  *   定义: `Result = Ok | Err`。
  * **ResultSymbol**: `Nominal.Create{}`
  * **OkSymbol**: `Nominal.Create{ ResultSymbol }`
  * **ErrSymbol**: `Nominal.Create{ ResultSymbol }`
  * **Ok**:
  ```
  (T) {
    Nominal.CreateMorphOf{ OkSymbol, { value: T } }
  }
  ```
  * **Err**: 
  ```
  (E) {
    Nominal.CreateMorphOf{ ErrSymbol, { value: E } }
  }
  ```
  。
* **impl ResultImpl for Result**:
  * **isOk{}**: 返回 Bool。
  * **unwrap{}**: 取值，若为 Err 则 Panic（或返回 Never）。
  * **map{ f }**: 映射 Ok 值。
  * **mapErr{ f }**: 映射 Err 值。

### 12.6 效应与能力

Morf 标准库提供了一组标准的 Effect 接口，用于统一错误处理与副作用管理。

* **Throw**: 异常抛出能力。
  * `impl Throw for Uni`
  * `raise: (error: Any) -> Never`: 抛出异常并中断当前控制流。

* **Rectify**: 可恢复错误能力。
  * `impl Rectify for Uni`
  * `fix: (issue: Issue) -> Bool`: 尝试修复问题。返回 `true` 表示已修复，调用者应重试；返回 `false` 表示放弃。

### 12.7 反射与元编程

* **Symbol**: 所有符号的父类型。
* **impl SymbolImpl for Symbol**:
  * **static Create{ description?: String }: Symbol**: 创建一个唯一符号。

* **Nominal**: 名义系统入口。
* **impl NominalImpl for Nominal**:
  * **static Create{ ...parents }**: 创建名义符号。
  * **static CreateMorph{ ... }**: 创建具名空间。该空间自动获得构造器能力（见 2.3.10）。
  * **static CreateMorphOf{ set: NominalSet, ns: Uni }**: 创建具名空间。该空间自动获得构造器能力（见 2.3.10）。
* **named**: `NominalImpl.CreateMorph`

### 12.8 基础逻辑

* **Bool**: `true | false`。
* **Assert**: 断言工具。
  * **static Eq{ a, b }**: 强相等检查。
  * **static True{ cond }**: 真值检查。

### 12.9 异步与并发

* **Future**: 代表一个正在执行或已完成的异步计算任务。
  * `impl FutureImpl for Future`:
    * `isReady: (self) -> Bool`: 检查任务是否已完成（非阻塞）。
    * `cancel: (self) -> Bool`: 尝试取消任务。

* **Async**: 异步流程控制工具。
  * `impl AsyncImpl for Async` (通常作为 `Async.All` 静态调用):
    * `static All: (tasks: Seq{ Future{T} }) -> Seq{T}`: 等待所有任务完成。
    * `static Race: (tasks: Seq{ Future{T} }) -> T`: 等待任意一个任务完成。
    * `static Sleep: (ms: Number) -> Uni`: 休眠当前 Fiber 指定时间。