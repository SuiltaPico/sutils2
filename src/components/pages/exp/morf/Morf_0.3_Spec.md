# Morf 0.3 Language Specification

## 0. 规范性关键字与术语

### 0.1 规范性关键字

本规范使用下列关键字表达规范性要求：

- **必须（MUST）/不得（MUST NOT）**：绝对要求。
- **应当（SHOULD）/不应当（SHOULD NOT）**：强烈建议；仅当存在充分理由时才允许偏离。
- **可以（MAY）**：可选特性或实现自由度。

除非明确标注为“实现建议/注释/示例”，否则本规范中的陈述均为规范性要求。

### 0.2 术语与记号

- **命名空间（Namespace）**：由键到值的不可变映射；在 Morf 中**值与类型统一**，因此命名空间既可以作为运行时值，也可以作为静态类型项参与计算。
- **键（Key）**：任何可作为映射索引的值（字符串、符号、数字或其他命名空间）。
- **值层（Value layer）**：程序求值后的运行时实体集合。
- **类型逻辑层（Type-logic layer）**：用于静态判定与归约的逻辑项层（`<:`、`|`、`&`、`~` 等）。
- **语义模型层（Semantic model layer）**：用于解释类型含义的集合论模型；仅用于说明，不要求作为运行时结构实现。

记号约定：

- **子类型**：`A <: B` 表示 $A$ 是 $B$ 的子类型。
- **定义等价**：`A ≡ B` 表示二者在类型逻辑层归约后为同一规范形（见 2.1.2）。
- **运行时相等**：`A == B` 表示运行时值相等（实现必须定义为可判定关系）。

## 1. 概述

本规范定义 Morf 0.3 语言的语法与静态/动态语义。Morf 是一门实验性语言，其核心统一构造是“命名空间”；类型系统以结构化子类型与类型逻辑正规形为基础，并通过名义属性引入可稳定标识的名义层。

### 1.1 设计原则与分层模型

为保证系统在处理极端代数结构（如嵌套集合、递归命名空间）时的一致性，Morf 遵循以下三层语义模型：

1.  **值层**：程序运行时的实体集合。包括命名空间实例、`None`、数字、字符串、序列（`Seq`）以及可变槽位（`Slot`）。
2.  **类型逻辑层**：用于静态判定与子类型计算的逻辑项（`<:`、`|`、`&`、`~`）。该层通过**规范化**归约为规范形，以保证等价与子类型判定的稳定性。
3.  **语义模型层**：用于解释类型的数学集合模型（如 `~T = Uni - T`）。这仅作为语义证明的参考，不作为值层的数据结构。

### 1.2 核心理念

1.  **万物皆命名空间**: 系统中的基本构成单元是键值对集合。
2.  **名义即属性**: 类型的名义不是一种特殊的难以访问的元数据，而是一个特殊的、不可伪造的属性。
3.  **数值与其关系**: 摒弃 IEEE 754 浮点数限制。数字之间仅存在大小比较关系（$<$）。
4.  **类型即值**: 类型和值的统一使得 Morf 自然支持高阶类型，类型构造器可以作为一等公民传递和操作。

---

## 2. 类型系统核心

Morf 的类型全集由以下基元和复合结构组成。

### 2.1 形式化约定与等价性

本规范使用以下约定来描述类型系统与计算规则。

#### 2.1.1 记号约定

- **子类型关系**：`A <: B` 表示 A 是 B 的子类型。
- **定义等价**：`A ≡ B` 表示 A 与 B 在类型系统中是同一个逻辑项。
- **运行时相等**：`A == B` 表示在运行时两者的值相等。
- **运算记号**：`A | B`（析取）、`A & B`（合取）、`~A`（补集）。

#### 2.1.2 规范形

为保证子类型判定与等价检查的稳定性，类型项在逻辑层会通过一组重写规则归约为**规范形**。
所有的逻辑运算（如 `DiSet` 的扁平化）都基于定义等价 `≡`。

### 2.2 子类型系统

Morf 遵循标准的结构化子类型规则。

#### 2.2.1 定义

##### 子类型
对于类型 $A$ 和 $B$，若 $A$ 是 $B$ 的子类型（记作 $A <: B$），则凡是需要 $B$ 的地方都可以安全地使用 $A$。

#### 2.2.2 命名空间子类型规则
在 Morf 中，命名空间在类型逻辑层被视为“对所有键均有定义的总映射”：当某键未被显式约束时，其值类型默认为 `Uni`（见 2.3.1）。因此传统结构子类型的“宽度/深度”规则可统一为逐键子类型。

**定义（键投影）**：对任意命名空间类型项 `T` 与任意键 `k`，`T[k]` 表示 `T` 对键 `k` 的值类型约束。实现必须按以下优先级计算 `T[k]`：

1. **具体键约束优先**：若 `T` 含有对某个具体键 `k` 的约束条目（字面量键或计算键，见 3.5.1/3.5.2），则 `T[k]` 必须等价于该条目的值类型。
2. **范围键其次**：否则，若 `T` 含有一个或多个范围键约束 `{ [...K_i]: V_i }`（见 3.5.3），且满足 `k <: K_i`，则 `T[k]` 必须取这些候选约束在“后来者覆盖”规则下生效后的值类型。
3. **默认值**：否则 `T[k] ≡ Uni`。即，未被约束的键默认为全集 `Uni`，而非空值 `None`。

> **边界定义（开放性）**：
> 根据上述规则 3，类型 `{ x: Number }` 在语义上等价于 `{ x: Number, [...Uni]: Uni }`。
> 这意味着类型定义默认是**开放的（Open）**：它允许实例包含未声明的额外属性。
> 若要定义**封闭类型（Closed Type）**（即禁止额外属性），必须显式使用范围键约束其他键为 `None`，例如：`{ x: Number, [...Uni]: None }`。

> 注（非规范性）：上述定义使得 `T` 可用有限条目描述一个“无限映射”，从而保持可实现性。

**规则（命名空间子类型）**：对任意命名空间类型项 `A` 与 `B`，

$$ A <: B \ \text{当且仅当}\ \forall k,\ A[k] <: B[k] $$

其中量化域为“所有可作为键的值”（值层宇宙）。实现可以采用等价的、保守的有限检查算法，但不得把满足上式的 `A <: B` 误判为假。

> 注（非规范性）：直观上，约束越多、约束越强，类型越窄。

### 2.3 核心基元

#### 2.3.1 命名空间（Namespace）
命名空间是键值对的不可变集合。

在 Morf 中，所有值都以“命名空间”统一表示；因此键和值在语义上都属于值层实体（可包含数字、字符串、符号等作为键/值）。

$$
\text{Namespace} = \{ k_1: v_1, \ k_2: v_2, \ \dots\}
$$

* **默认属性**：在未加约束的情况下，任何键的值默认为 `Uni`。

#### 2.3.2 顶空间（Uni）
表示“无具体约束”的命名空间。它是命名空间的**顶类型**。在 Morf 中可以使用 `{}` 表达。

* **子类型关系**：顶空间是所有类型的父类型。
$$
\text{Uni} =  \{ k: \text{Uni} \mid \forall k \}
$$
* **键定义**：其所有键都是顶空间。
* **构成**: 
$$
\text{Uni} = \text{Proof} \cup \text{None}
$$

在下文，我们称其为 Uni。

#### 2.3.3 底空间（Never）
表示**不可居住（uninhabited）**的类型（语义模型层的空集合）。它是命名空间类型体系中的**底类型**，常用于表示逻辑矛盾或不可满足的约束。

$$
\text{Never} \equiv DiSet\{ \} \equiv \sim \text{Uni}
$$


* **子类型关系**：底空间是所有类型的子类型。
* **键定义**：其所有键都是底空间。

在下文，我们称其为 Never。


#### 2.3.4 空值（None）
表示“值的缺失”或“无效信息”，但它本身是一个合法的、存在于 Uni 中的值。

* **定义**:
$$ \text{None} = \{ k: \text{None} \mid \forall k \} $$
* **语法表达**: 在语言层面可表达为 `None = { [...Uni]: None }`。
* **传染性**：由于其递归定义，对 None 进行任意深度的属性访问，结果永远是 None。这使得 Optional Chaining 成为类型的内禀属性，而非语法糖。
* **特性**: 
$$
\text{None} = \sim\text{Proof}
$$

在下文，我们称其为 None。

#### 2.3.5 实存（Proof）
表示“有效信息”的集合。它是顶空间中除去 None 之外的所有部分。
$$ \text{Proof} = \sim \text{None} $$
* **定义**：任意值 \(v\)，若 \(v \not\equiv None\)，则 \(v \in Proof\)。

在下文，我们称其为 Proof。


#### 2.3.6 命名空间的补集
$\sim \text{Type}$ 表达 Uni 中所有不属于 $\text{Type}$ 的命名空间。

$$ \sim T = \text{Uni} - T $$

#### 2.3.7 析取/合取（`DiSet` / `ConSet`）
本节讨论的是**类型逻辑层**的“或/与”正规形，而不是值层的数据容器。

- `DiSet{ ... }`：析取（并类型 / Union type）的规范形
- `ConSet{ ... }`：合取（交类型 / Intersection type）的规范形

##### 析取集（DiSet）
`DiSet` 表示“可能是这些之一”（逻辑 $\lor$）。其规范化遵循结合/交换/幂等等价，从而**不存在可观察的嵌套 `DiSet`**。

**规范化（定义等价 `≡`）**：

- **扁平化**：`DiSet{ ..., DiSet{ X... }, ... } ≡ DiSet{ ..., X..., ... }`
- **去重（幂等）**：`DiSet{ ..., A, ..., A, ... } ≡ DiSet{ ..., A, ... }`
- **单元素消除**：`DiSet{ A } ≡ A`
- **空析取**：`DiSet{ } ≡ Never`

**子类型规则**：

- 对于 `DiSet{A...}` 与 `DiSet{B...}`：
  - 若 \( \forall x \in \{A...\}, \exists y \in \{B...\}, x <: y \), 则 `DiSet{A...} <: DiSet{B...}`

> 注（非规范性）：分支越多越宽；左边每个分支都能“提升到”右边某个分支，则左更窄。

##### 合取集（ConSet）
`ConSet` 表示“同时满足这些约束”（逻辑 $\land$）。其规范化同样遵循结合/交换/幂等等价，从而**不存在可观察的嵌套 `ConSet`**。

**规范化（定义等价 `≡`）**：

- **扁平化**：`ConSet{ ..., ConSet{ X... }, ... } ≡ ConSet{ ..., X..., ... }`
- **去重（幂等）**：`ConSet{ ..., A, ..., A, ... } ≡ ConSet{ ..., A, ... }`
- **单元素消除**：`ConSet{ A } ≡ A`
- **空合取**：`ConSet{ } ≡ Uni`

**子类型规则**：

- `ConSet{A, B} <: A` 且 `ConSet{A, B} <: B`
- 若 `C <: A` 且 `C <: B`, 则 `C <: ConSet{A, B}`


#### 2.3.8 符号（Symbol）
每一个符号都是一个全局唯一的命名空间。

* **不可访问性**: 对符号的任意 key 访问都返回 `None`，但在定义上其与 `None` 不相等，在定义上，其有一个隐式的、不可见的唯一标识符。

#### 2.3.9 名义符号集（NominalSet）
用于实现名义系统的命名空间。它是一个 ConSet，被专用于标识名义，和记录名义的继承关系。

$$
\text{NominalSet} = \{ \text{NominalKey}: \text{NominalOfNominal} \} \cup ConSet \{ \upsilon_k \} \\
$$

##### 名义符号（NominalSymbol）
在名义符号集中使用的，用于指定名义的符号称为名义符号。

##### 名义的核心常量
以下这些符号因为有循环定义问题，所以作为公理化存在：
* **名义符号的名义（$\text{NominalOfNominal}$）**：是一个名义符号集，用于区分命名空间是否是一个名义符号集。
* **名义属性（$\text{NominalKey}$）**：是一个符号，它的在命名空间中通常作为键存在，其对应的值是当前命名空间的名义符号集。

##### 名义继承
若类型 $T$ 的名义符号集为 $S_T=\{ \upsilon_T \}$，要构建其子类型 $U$：
1. 创建新符号 $\upsilon_U$
2. 构造 $S_U = S_T \cup \{ \upsilon_U \}$
3. 由 $S_U <: S_T$，得 $U <: T$

##### 具名空间（NamedNamespace）
名义属性为名义符号集的命名空间称为具名空间。

$$
\text{NamedNamespace}=\{ \text{NominalKey}: \text{NominalSet}, ... \}
$$


### 2.4 复合结构

#### 2.4.1 函数
参数化的命名空间构造器。
$$
f: (\text{Args}) \to \mathbb{T}
$$

* **命名空间签名**:

```morf
{
  [NominalKey]: FunctionNominal
  params: { [string]: Uni }
}
```
  
---

## 3. 运算体系

### 3.1 核心算符与优先级
内置的表达式算符，优先级从高到低如下。同一行中的算符具有相同的优先级。

| 优先级 | 算符类型 | 算符符号 | 结合性 | 备注 |
| :--- | :--- | :--- | :--- | :--- |
| 1 | 属性访问 | `.`, `[]`, `<>.`, `<>[]` | 左 | 最高优先级 |
| 2 | 展开/剩余 | `...` | 右 | 前缀算符 |
| 3 | 一元算符 | `!`, `*~` (按位取反), `-` (负号), `~` (补集), `&` (取引用) | 右 | |
| 4 | 乘除求余 | `*`, `/`, `%` | 左 | 系统分派，**不可重载** |
| 5 | 加减 | `+`, `-` | 左 | 系统分派，**不可重载** |
| 6 | 移位 | `<<`, `>>` | 左 | 仅用于 Integer |
| 7 | 比较 | `<`, `>`, `<=`, `>=` | 左 | 系统分派，**不可重载** |
| 8 | 相等 | `==`, `!=` | 左 | 系统分派，**不可重载** |
| 9 | 按位与 | `*&` | 左 | 仅用于 Integer |
| 10 | 按位异或 | `*^` | 左 | 仅用于 Integer |
| 11 | 按位或 | `*|` | 左 | 仅用于 Integer |
| 12 | 类型算符 | `&` (交集), `\|` (并集) | 左 | 类型逻辑层运算 |
| 13 | 类型关系 | `<:` (子类型), `>:` (父类型) | 左 | 静态关系判定 |
| 14 | 逻辑与 | `&&` | 左 | 短路求值 |
| 15 | 逻辑或 | `||` | 左 | 短路求值 |
| 16 | 空值合并 | `??` | 左 | 短路求值 |
| 17 | 赋值 | `=`, `+=`, `-=`, `*=`, `/=` 等 | 右 | 最低优先级 |

> **注（不可重载）**: 本规范明确规定，Morf 的二元算符（如 `+`, `-`, `*` 等）在当前版本中**不允许用户重载**。其语义由系统内置的 `Promote` 和 `Impl` 机制（如 `ArithC`）统一分派，以保证语义的一致性与可预测性。

### 3.2 类型运算符

本节定义类型逻辑层的核心运算符在语法层的表示，以及它们在类型逻辑层的规范化结果。

- **析取（并类型）**：`A | B` 的类型逻辑规范形必须为 `DiSet{A, B}`，并遵循 `DiSet` 的扁平化/去重/单元素消除/空析取规则（见 2.3.7）。
- **合取（交类型）**：`A & B` 的类型逻辑规范形必须为 `ConSet{A, B}`，并遵循 `ConSet` 的扁平化/去重/单元素消除/空合取规则（见 2.3.7）。若约束不可满足，实现必须将其规范化为 `Never`。
- **补集**：`~A` 表示 `Uni` 中不属于 `A` 的部分；其语义模型解释为 `Uni - A`（见 2.3.6）。实现可以采用等价的逻辑归约表示，但必须保持与子类型判定一致。

### 3.3 展开与剩余参数算符

展开/剩余参数算符 `...` 是一个前缀算符，在不同语境下具有互逆的语义：

* **展开**：在构造表达式中使用，将集合"拆开"并插入到目标位置
* **剩余参数**：在解构/定义中使用，将多个元素"收集"成一个集合

#### 3.3.1 展开语义

##### 命名空间展开

在命名空间构造中，`...` 将源命名空间的所有键值对展开到目标位置。

* **语法**: `{ ...source, key: value }`
* **语义**: 以**从左到右**顺序求值各个展开源与显式键值对，并依序合并到新命名空间；当存在同名键冲突时，**后出现者必须覆盖先出现者**。
* **类型**: 展开结果的类型为 `source` 类型与新增属性的交集

**示例**:
```morf
let base = { x: 1, y: 2 }
let extended = { ...base, z: 3 }
// extended = { x: 1, y: 2, z: 3 }

// 后来者覆盖
let overridden = { ...base, x: 10 }
// overridden = { x: 10, y: 2 }

// 多次展开
let merged = { ...base, ...{ z: 3, w: 4 }, x: 100 }
// merged = { x: 100, y: 2, z: 3, w: 4 }
```

##### 函数调用展开

在函数调用中，`...` 将命名空间的所有属性作为参数展开传递。

* **语法**: `f{ ...args, key: value }`
* **语义**: 以从前到后顺序合并实参命名空间；显式参数必须覆盖同名参数。合并后的命名空间作为一次调用的实参命名空间。

**示例**:
```morf
let params = { x: 1, y: 2 }
let add = (x, y) { x + y }

add{ ...params }        // 等价于 add{ x: 1, y: 2 }
add{ ...params, y: 10 } // 等价于 add{ x: 1, y: 10 }
```

##### 序列展开

在序列构造中，`...` 将序列的所有元素按顺序展开。

* **语法**: `[...seq1, item, ...seq2]`
* **语义**: 将序列元素按顺序展开并合并

**示例**:
```morf
let arr1 = [1, 2, 3]
let arr2 = [4, 5]
let combined = [...arr1, ...arr2]
// combined = [1, 2, 3, 4, 5]

let withExtra = [0, ...arr1, 99]
// withExtra = [0, 1, 2, 3, 99]
```

#### 3.3.2 剩余参数语义

在函数参数定义中，`...` 用于收集剩余的参数。这与展开语义相反：不是"拆开"而是"收集"。

##### 位置参数收集：`...[]params`

使用 `...[]` 收集所有未匹配的位置参数（数字索引键）。

* **语法**: `(...[]params) { expr }`
* **语义**: `params` 接收所有剩余位置参数，组成序列（Seq）
* **类型**: `params` 的类型为 `Seq`

**示例**:
```morf
// 收集所有位置参数
let collect = (...[]xs) { xs }
collect{ 1, 2, 3 }  // xs = [1, 2, 3]

// 混合使用
let first_and_rest = (head, ...[]tail) { { head, tail } }
first_and_rest{ 1, 2, 3, 4 }
// head = 1, tail = [2, 3, 4]
```

##### 命名参数收集：`...params`

使用 `...` 收集所有未匹配的命名参数（非数字键）。

* **语法**: `(...params) { expr }`
* **语义**: `params` 接收所有剩余命名参数，组成命名空间
* **类型**: `params` 的类型为命名空间

**示例**:
```morf
// 收集所有命名参数
let collect_props = (...props) { props }
collect_props{ x: 1, y: 2, z: 3 }
// props = { x: 1, y: 2, z: 3 }

// 混合使用
let with_name = (name, ...attrs) { { name, attrs } }
with_name{ name: "Morf", version: 1, author: "Me" }
// name = "Morf", attrs = { version: 1, author: "Me" }
```

##### 混合参数模式

可以同时使用命名参数、位置收集和命名收集，实现复杂的参数匹配。

* **语法**: `(a, b, ...[]xs, ...ys) { expr }`
* **匹配规则**:
  1. 优先匹配显式命名的参数
  2. 剩余位置参数按顺序匹配未绑定的命名参数
  3. `...[]xs` 收集剩余的位置参数
  4. `...ys` 收集剩余的命名参数

**示例**:
```morf
let complex = (a, b, ...[]xs, ...ys) { { a, b, xs, ys } }

complex{ b: 1, c: 2, 3, 4, 5 }
// 匹配过程：
// 1. b: 1 显式匹配到参数 b
// 2. c: 2 没有对应命名参数，进入 ys
// 3. 位置参数 0: 3, 1: 4, 2: 5
// 4. a 吸收第一个位置参数 3
// 5. xs 收集剩余位置参数 [4, 5]
// 结果: a = 3, b = 1, xs = [4, 5], ys = { c: 2 }
```

#### 3.3.3 类型层面的展开

展开运算符在类型计算中遵循**结构化覆盖**规则，而非简单的交集。

* **覆盖规则**: `{ ...A, ...B }` 的结果类型是一个新的命名空间类型。对于 A 和 B 中共有的键，B 的类型约束**覆盖** A 的类型约束（类似于值层面的行为）。
* **非交集**: `{ x: 1 } & { x: 2 }` 是 `Never`（互斥），但 `{ ...{x: 1}, ...{x: 2} }` 是 `{ x: 2 }`。
* **子类型关系**: 展开操作产生的新类型与原类型之间通常没有直接的子类型关系，除非结构恰好兼容。

**示例**:
```morf
let TypeA = { x: Number, y: String }
let TypeB = { x: String, z: Boolean }

let MergedType = { ...TypeA, ...TypeB }
// MergedType ≡ { x: String, y: String, z: Boolean }
// 注意 x 的类型变成了 String (来自 TypeB)
```

#### 3.3.4 展开与不可变性

由于 Morf 的命名空间是不可变的，展开运算符总是创建新的命名空间，而不是修改原有对象。

**示例**:
```morf
let original = { x: 1 }
let copy = { ...original }

// original 和 copy 是不同的命名空间
// 但可能共享内部结构（实现细节）
```

### 3.4 访问运算符

访问运算符用于从命名空间中获取属性值。Morf 提供两种访问语法：点号访问和方括号访问。

#### 3.4.1 点号访问

点号访问用于访问字符串字面量键。

* **语法**: `namespace.identifier`
* **语义**: 访问命名空间中键为字符串 `"identifier"` 的属性
* **键类型**: 键必须是合法的标识符（字母开头，包含字母、数字、下划线）
* **返回值**: 返回对应的属性值；若键不存在，返回 `None`

**示例**:
```morf
let obj = { x: 1, y: 2, name: "Morf" }

obj.x      // 1
obj.name   // "Morf"
obj.z      // None（键不存在）
```

**链式访问**:
```morf
let nested = { 
  user: { 
    profile: { 
      name: "Alice" 
    } 
  } 
}

nested.user.profile.name  // "Alice"
nested.user.settings      // None
nested.user.settings.theme // None（None 的传染性，见 2.3.4）
```

#### 3.4.2 方括号访问

方括号访问用于访问任意类型的键，包括命名空间键、动态计算的键等。

* **语法**: `namespace[keyExpr]`
* **语义**: 先求值 `keyExpr`，然后使用结果作为键访问命名空间
* **键类型**: 键可以是任意命名空间（字符串、符号、数字等）
* **返回值**: 返回对应的属性值；若键不存在，返回 `None`

**基本示例**:
```morf
let obj = { x: 1, y: 2 }

obj["x"]        // 1，等价于 obj.x
obj["y"]        // 2

// 动态键
let key = "x"
obj[key]        // 1
```

**命名空间键示例**:
```morf
// 使用符号作为键
let sym = Symbol.Create{}
let secretData = { [sym]: "Hidden Value" }

secretData[sym]       // "Hidden Value"
secretData.sym        // None（点号访问查找字符串键 "sym"）
```

**数字键示例**:
```morf
let tuple = [10, 20, 30]

tuple[0]        // 10
tuple[1]        // 20
tuple[2]        // 30
tuple.length    // 3（length 是字符串键）
```

#### 3.4.3 点号与方括号的等价性

对于字符串键，点号访问和方括号访问是等价的：

```morf
obj.key  ≡  obj["key"]
```

但是：
- 点号只能访问字面标识符
- 方括号可以访问任意表达式计算出的键

#### 3.4.4 与 Impl 系统的集成

访问运算符与 Impl 系统集成。当数据层面未找到对应键时，系统会自动在适用的 Impl 中查找同名方法（详见第 10 章）。

**查找顺序**:
1. **数据优先**: 首先检查命名空间自身是否包含该键
2. **Impl 兜底**: 若数据层面未找到，在适用的 Impl 中查找方法

**显式 Impl 指定**:
当需要显式指定使用哪个 Impl，或绕过数据遮蔽时，使用尖括号语法：

* **点号形式**: `namespace<ImplId>.method`
* **方括号形式**: `namespace<ImplId>[keyExpr]`

```morf
let obj = { 
  value: 100,
  getValue: "data"
}

// 隐式访问：数据优先
obj.getValue              // "data"

// 显式 Impl：绕过数据层
obj<DataOps>.getValue{}   // 100
```

完整的 Impl 系统规则、继承、冲突解决等详见第 10 章。

#### 3.4.5 访问运算符的类型计算

访问运算符的返回类型取决于被访问命名空间的类型和键的类型。

本节同时给出运行时求值语义与静态类型计算规则。实现必须保证两者一致：若表达式经类型检查成立，则运行时求值不得产生违反该类型结论的值（除 `Never` 坍缩语义外）。

##### 运行时语义（数据访问）

令 `GetData(v, k)` 表示对运行时值 `v` 进行“数据层键查找”（不触发 Impl 兜底）。其行为必须满足：

- 若 `v == None`，则 `GetData(v, k) == None`。
- 否则若 `v` 在数据层显式包含键 `k`，则 `GetData(v, k)` 等于该键对应的值。
- 否则 `GetData(v, k) == None`。

点号访问 `E.id` 的运行时键必须为字符串键 `"id"`；方括号访问 `E[keyExpr]` 的运行时键必须为 `keyExpr` 求值得到的值。

##### 运行时语义（Impl 兜底）

当且仅当点号/方括号访问发生在“可调用上下文”的方法位（即形如 `E.Method{ ... }`、`E[Key]{ ... }`、`E<ImplId>.Method{...}`、`E<ImplId>[Key]{...}`）时，实现必须按本规范的 Impl 查找规则进行兜底分派，并按方法修饰符进行脱糖调用（普通方法注入 `self`，静态方法不注入）。

> 注：这条约束避免了“仅访问但不调用”时引入不可预测的隐式方法值（例如 `let m = obj.foo` 的语义）。若实现希望支持“绑定方法值”，必须以额外的、可显式辨识的值形态引入（非本版本规范所要求）。

##### 静态类型计算

为定义访问的静态类型，先定义“键投影” `T[k]`（见 2.2.2）：

- 对于点号访问 `E.id`，其键投影使用 `k = "id"`。
- 对于方括号访问 `E[keyExpr]`，若 `keyExpr` 可在类型层归约为某个**单例键** `k`（例如字符串字面量、符号单例、数字单例等），则使用该 `k`；否则其结果类型必须保守地取为 `Uni`。

**规则（命名空间访问）**：若表达式 `E` 的类型为命名空间类型项 `T`，则：

- `E.id` 的类型必须为 `T["id"]`。
- 若 `keyExpr` 可静态确定为单例键 `k`，则 `E[keyExpr]` 的类型必须为 `T[k]`；否则类型为 `Uni`。

**规则（对 `DiSet` 的分布）**：若 `E` 的类型为 `DiSet{T1, T2, ...}`，则访问操作必须对每个分支分布，并将结果规范化：

```morf
let U = DiSet{ { x: Number }, { x: String } }
// U.x 的类型为 DiSet{ Number, String }
```

**规则（对 `None`）**：`None.k` 与 `None[anything]` 的类型必须为 `None`。

#### 3.4.6 优先级与结合性

访问运算符具有最高优先级（高于所有二元运算符），采用左结合。

```morf
obj.a.b.c     // 从左到右：((obj.a).b).c
arr[0][1]     // 从左到右：(arr[0])[1]
obj.method{}  // 先访问 obj.method，再调用结果
```

**与其他运算符的组合**:

```morf
obj.method{ arg }           // 访问后调用
obj<Impl>.method{ arg }     // 显式 Impl + 访问 + 调用
obj[key]{ arg }             // 动态访问后调用
```

### 3.5 键定义语法

在构造命名空间时，Morf 支持三种键定义形式，用于灵活地描述属性与约束。

#### 3.5.1 字面量键

* **语法**: `{ Key: Value }`
* **语义**: 键是一个字符串字面量 `"Key"`。这是最常用的形式。
* **等价性**: 等价于 `{ ["Key"]: Value }`。

#### 3.5.2 计算键

* **语法**: `{ [Expr]: Value }`
* **语义**: 先求值表达式 `Expr`，将结果作为该属性的键。
* **用途**: 用于使用符号、变量或动态计算的值作为键。

#### 3.5.3 范围键

* **语法**: `{ [...Type]: Value }`
* **语义**: 这是一个**全量约束**。表示对于任何键 `k`，只要满足 `k <: Type`，则该属性的值均为 `Value`。
* **冲突处理**: 
    - 如果多个范围键覆盖了同一个具体的键，则遵循“后来者覆盖”原则。
    - 具体键（字面量键或计算键）的优先级高于范围键。

### 3.6 算术运算符

Morf 提供标准的算术运算符，用于数值计算与字符串拼接。

*   **加法**: `a + b`
*   **减法**: `a - b`
*   **乘法**: `a * b`
*   **除法**: `a / b`
*   **取余**: `a % b`
*   **负号**: `-a` (一元)

#### 3.6.1 运算规则

*   **数值运算**: 当操作数均为数值类型时，执行数学运算。
    *   **类型提升**: 混合类型的数值运算会自动提升到公共类型（见 5.4.4）。
    *   **溢出检查**: 默认启用溢出检查，溢出时抛出异常（见 5.4.7）。
    *   **除零**: 整数除零引发异常；浮点数除零遵循 IEEE 754（产生 `Infinity` 或 `NaN`）。
*   **字符串拼接**: `+` 运算符可用于 `String + String`，表示字符串连接。
*   **不可重载**: 用户无法重载这些运算符。

```morf
let x = 10 + 20        // 30
let s = "Hello" + "!"  // "Hello!"
let f = 3.14 * 2.0     // 6.28
```

### 3.7 移位运算符

移位运算符仅适用于**整数类型**（Integer）。

*   **左移**: `a << n`。将 `a` 的二进制位向左移动 `n` 位，右侧补 0。
*   **右移**: `a >> n`。将 `a` 的二进制位向右移动 `n` 位。
    *   对于**无符号整数** (Unsigned)，执行逻辑右移（高位补 0）。
    *   对于**有符号整数** (Signed)，执行算术右移（高位补符号位）。

```morf
let a: U8 = 0b0000_0001
let b = a << 2         // 0b0000_0100

let c: I8 = -8         // 0b1111_1000
let d = c >> 1         // 0b1111_1100 (-4)
```

### 3.8 比较运算符

比较运算符返回布尔值 `Bool` (`True | False`)。

#### 3.8.1 相等性比较

*   **等于**: `a == b`
*   **不等于**: `a != b`

**语义**:
*   **结构化相等**: 对于命名空间（包括序列、元组等），`==` 默认执行深度结构化比较。当且仅当所有键值对递归相等时，两个命名空间相等。
*   **mut 变量**: 由于 `mut` 变量在表达式中会自动解包（Auto-dereference），`==` 比较的是其**当前值**，而非槽位身份。
    *   若需比较槽位身份，必须使用 `&` 运算符获取引用（见 3.13）。
*   **名义身份**: 对于 `Symbol`，比较其唯一身份标识。
*   **类型安全**: `==` 允许比较任意类型的值。若两个值的类型交集为 `Never`（完全不兼容），实现可以发出静态警告，且运行时结果恒为 `False`。

```morf
let p1 = { x: 1, y: 2 }
let p2 = { x: 1, y: 2 }
p1 == p2  // True (结构相等)

let s1 = Symbol.Create{}
let s2 = Symbol.Create{}
s1 == s2  // False (每一个 Symbol 都是唯一的)
```

#### 3.8.2 序关系比较

*   **小于**: `a < b`
*   **大于**: `a > b`
*   **小于等于**: `a <= b`
*   **大于等于**: `a >= b`

**语义**:
*   仅定义在支持序关系的类型上（如 Number, String）。
*   对于数值，遵循数学大小关系。
*   对于字符串，遵循字典序（Lexicographical Order）。

### 3.9 数值位运算符

为了避免与类型逻辑运算符（`&`, `|`, `~`）混淆，并明确区分“集合操作”与“底层位操作”，Morf 引入了一组带有 `*` 前缀的专用位运算符。

> **Q: Number 本体何来的位概念？**
> A: 抽象的 `Number` 类型是数学上的数值集合，不具有机器表示的“位”概念。因此，本节定义的位运算符**仅对具体整数类型（Integer: I8-I64, U8-U64）有效**。对 `Float` 或抽象 `Number` 使用位算符将导致类型错误。

*   **按位与**: `a *& b`
*   **按位或**: `a *| b`
*   **按位异或**: `a *^ b`
*   **按位取反**: `*~a` (一元算符)

这些算符的行为遵循标准二进制补码运算规则。参与运算的操作数将被提升（Promote）到相同的整数类型后进行计算。

```morf
let x: U8 = 0b0000_1111
let y: U8 = 0b0000_1010

x *& y   // -> 0b0000_1010
x *| y   // -> 0b0000_1111
*~x      // -> 0b1111_0000
```

### 3.10 逻辑运算符

逻辑运算符用于布尔逻辑组合，支持短路求值。

*   **逻辑与**: `a && b`
*   **逻辑或**: `a || b`
*   **逻辑非**: `!a`

#### 3.10.1 类型约束与真值

Morf 采用严格的布尔逻辑。
*   操作数必须是 `Bool` 类型（`True` 或 `False`）。
*   不提供隐式的 "Truthy/Falsy" 转换（如将 `0` 或 `None` 视为假）。若需判断是否存在，应显式使用比较（如 `val != None`）。

#### 3.10.2 短路求值

*   `a && b`: 若 `a` 为 `False`，则直接返回 `False`，不求值 `b`。
*   `a || b`: 若 `a` 为 `True`，则直接返回 `True`，不求值 `b`。

```morf
let check = (x) {
  x != None && x > 0
}
```

### 3.11 空值合并运算符

空值合并运算符 `??` 提供了一种处理 `None` 的便捷方式。

*   **语法**: `L ?? R`
*   **语义**:
    1.  求值 `L`。
    2.  若 `L` 不为 `None`，则结果为 `L`（此时 `R` **不求值**，即短路）。
    3.  若 `L` 为 `None`，则求值并返回 `R`。
*   **类型**: 结果类型为 `(Type(L) - None) | Type(R)`。

```morf
let val = maybeNone ?? "default"
// 等价于
let val = Cond {
  Branch{ maybeNone != None, maybeNone },
  Else{ "default" }
}
```

### 3.12 赋值运算符

Morf 支持基本的赋值与复合赋值操作。赋值操作仅对 `mut` 声明的变量槽位（Slot）有效（见第 8 章）。

*   **基本赋值**: `a = b`。将 `b` 的值写入 `a` 对应的槽位。表达式的值为 `b`（右值）。
*   **复合赋值**: `+=`, `-=`, `*=`, `/=`, `%=`, `??=`, `*&=`, `*|=`, `*^=` 等。
*   **语义**: `a op= b` 语义上等价于 `a = a op b`，但 `a` 的地址计算（如果涉及属性访问）只进行一次。

### 3.13 取引用运算符

为了在需要时获取 `mut` 变量的槽位本身（而不是其值），Morf 引入了一元前缀运算符 `&`。

*   **语法**: `&variable`
*   **语义**: 获取 `variable` 对应的内存槽位（Slot）的引用。
*   **类型**: 若 `x` 的类型为 `T`，且 `x` 是 `mut` 绑定的，则 `&x` 的类型为 `Slot<T>`（一种特殊的系统内建类型）。
*   **用途**:
    1.  **身份比较**: 判断两个变量是否指向同一个存储槽位。
    2.  **传递引用**: 将槽位传递给接受 `mut` 参数的函数（虽然函数调用时通常会自动处理，但在某些泛型上下文中显式取址可能更清晰）。

```morf
mut a = 1
mut b = 1

a == b   // True  (值相等)
&a == &b // False (槽位不同)

let refA = &a // refA 持有对 a 的引用
```

### 3.14 变量绑定与解构

Morf 支持在 `let` 声明和赋值语句中使用模式匹配进行解构。

#### 3.14.1 命名空间解构

*   **基本语法**: `let { key1, key2 } = namespaceExpr`
*   **重命名**: `let { sourceKey: newName } = namespaceExpr`
*   **默认值**: `let { key = defaultValue } = namespaceExpr`
    *   若对应键的值为 `None`，则使用 `defaultValue`。
*   **剩余属性**: `let { x, ...rest } = namespaceExpr`
    *   `rest` 收集除 `x` 以外的所有剩余属性为一个新的命名空间。

**示例**:
```morf
let user = { id: 1, name: "Alice", meta: "data" }

// 基本解构
let { id, name } = user
// id = 1, name = "Alice"

// 重命名与默认值
let { id: uid, role = "Guest" } = user
// uid = 1, role = "Guest" (因为 user 中没有 role)

// 剩余属性
let { meta, ...coreInfo } = user
// coreInfo = { id: 1, name: "Alice" }
```

#### 3.14.2 序列解构

由于序列（Seq/Tuple）也是命名空间（键为数字索引），解构语法通过 `[]` 糖衣支持位置解构。

*   **语法**: `let [a, b, ...rest] = seqExpr`
*   **语义**: 等价于访问索引 `0`, `1` 等。
*   **跳过元素**: `let [first, , third] = seqExpr`

```morf
let point = [10, 20, 30]

let [x, y] = point
// x = 10, y = 20

let [head, ...tail] = point
// head = 10, tail = [20, 30]
```

---

## 4. 流程控制与块表达式

为了支持优雅的业务逻辑编排，Morf 引入了非严格求值的块语法。

### 4.1 块表达式
使用圆括号 `( ... )` 包裹一系列语句，构成一个块表达式。
* **求值顺序**：块内语句必须按书写顺序求值。
* **结果值**：块中最后一个表达式的值，作为整个块表达式的值。
* **词法作用域**：块表达式必须引入新的词法作用域；块内 `let/mut` 声明的绑定不得泄漏到块外。
* **示例**：`( let a = 1; f{a}; Ok{a} )`。

### 4.2 自动 Thunk
为了实现“懒执行”的控制流，Morf 引入了自动 Thunk 机制。

#### 4.2.1 参数修饰符：`wrap`
在函数定义时，可以为参数添加 `wrap` 前缀，标识该参数为“延迟求值”参数。
* **语义**: 当调用该函数时，若某个实参表达式被绑定到 `wrap` 参数，则该表达式**不得在调用点求值**，而必须被自动包装为一个零参函数 `() { ... }`（Thunk）并传入。
* **求值时机**：Thunk 仅在其被调用（`thunk{}`）时才对原表达式求值。
* **纯度**：构造 Thunk 本身必须是纯操作；表达式的 Effect 由后续调用释放并传播（见 Effect 规则）。
* **定义示例**: 
    `let Branch = (c, wrap d) { { case: c, do: d } }`
* **调用示例**:
    ```javascript
    // 下面两者等价，Sys.Log{} 均不会立即执行
    Branch{ x > 0, Sys.Log{ "Ok" } }
    Branch{ x > 0, ( Log{ "Ok" }; True ) }
    ```

#### 4.2.2 逃逸修饰符：`directly`
如果参数被标记为 `wrap`，但调用者希望直接传递一个值（例如已经包装好的函数或特定的 Namespace）而不被再次包装，则使用 `directly` 关键字。
* **语法**: `f{ directly { expr } }`
* **语义**: 当 `directly { expr }` 被绑定到某个 `wrap` 参数时，实现必须强制跳过自动 Thunk 逻辑，直接对 `expr` 求值并传递其值。
* **示例**:
    `Branch{ x > 0, directly { mySavedThunk } }`

### 4.3 函数定义语法

Morf 使用圆括号 `()` 定义参数列表，大括号 `{}` 定义函数体。函数定义语法与调用语法高度统一，支持命名参数、位置参数、展开运算符等特性。

#### 4.3.1 基本定义语法

函数定义本身是一个表达式，求值结果为函数值（闭包），该闭包捕获定义时的词法环境。

* **无参函数**: `() { expr }`
* **命名参数**: `(a, b) { expr }`
* **带返回值标注**: `(args) -> ReturnType { expr }`
* **函数体**: 大括号内可以是单个表达式或包含多条语句的块

**示例**:
```morf
// 无参函数
let greet = () { "Hello" }

// 带返回值标注
let add = (x, y) -> Number { x + y }

// 多语句函数体
let compute = (n) {
  let doubled = n * 2
  let squared = doubled * doubled
  squared
}
```

#### 4.3.2 参数与调用的映射关系

函数调用使用大括号 `{}` 进行，调用时的参数会被映射到一个命名空间（Namespace）。

本节定义“实参项列表 → 形参绑定”的规范性算法。该算法的目标是：

- 明确参数匹配优先级（命名优先、位置补齐、剩余收集）；
- 明确求值顺序（严格左到右），并与 `wrap/directly` 的非严格语义一致；
- 使得实现可在不引入运行时歧义的前提下实现关键字参数、展开与剩余参数。

##### 实参项

函数调用 `f{ ... }` 的实参由逗号分隔的“实参项”构成。实现必须支持至少以下形态：

- **位置实参**：`Expr`
- **命名实参**：`name: Expr`（其中 `name` 是标识符；其键为字符串 `"name"`）
- **展开实参**：`...Expr`（其中 `Expr` 必须求值为命名空间）
- **逃逸实参**：`directly { Expr }`（仅对绑定到 `wrap` 形参时有意义）

##### 绑定算法（规范性）

令被调用的函数值为 `F`，其形参列表为按声明顺序排列的序列。每个形参是下列之一：

- 普通形参：`p` 或 `p: Type` 或 `wrap p` 或 `wrap p: Type`
- 位置剩余形参：`...[]xs`（至多一个）
- 命名剩余形参：`...ys`（至多一个）

实现必须按如下步骤完成一次调用的形参绑定与求值。

**步骤 1：左到右收集实参贡献**

实现必须从左到右处理实参项，并构造一个“实参命名空间” `A`。其中每个条目来自以下之一：

- 对于展开实参 `...E`：实现必须立即对 `E` 求值，得到命名空间 `S`，并将 `S` 的全部键值对合并进 `A`；若键冲突，后出现者覆盖先出现者。
- 对于命名实参 `name: E`：实现必须在 `A` 中写入键 `"name"` 的条目，其值为一个**待定实参** `ArgExpr(E)`，并记录其在源代码中的相对顺序。若同一键在 `A` 中被再次写入，后出现者覆盖先出现者。
- 对于位置实参 `E`：实现必须在 `A` 中写入键 `i`（从 0 开始递增的整数键）的条目，其值为 `ArgExpr(E)`，并记录顺序；随后 `i += 1`。
- 对于逃逸实参 `directly { E }`：其本身不是独立的键值对；它仅作为某个命名/位置实参的 `E` 形式出现，用于在步骤 3 中抑制自动 wrap。

> 注：`ArgExpr(E)` 表示“尚未求值的实参表达式”。该结构仅是规范性描述；实现可以用闭包、IR 节点或 thunk 记录之。

**步骤 2：形参匹配（命名优先，位置补齐，剩余收集）**

在此步骤中，实现不得对任何 `ArgExpr` 求值，仅决定每个形参绑定到 `A` 的哪个键（若有）。

- **命名匹配**：对每个普通形参 `p`（含 `wrap` 与类型标注），若 `A` 中存在键 `"p"`，则该形参绑定到该条目。
- **位置补齐**：对仍未绑定的普通形参，按声明顺序依次从 `A` 中取用键 `0, 1, 2, ...`（跳过不存在的键），并绑定到该条目。
- **位置剩余收集**：若声明了 `...[]xs`，则 `xs` 绑定为一个序列（`Seq`），其元素为 `A` 中所有**未被消耗**的整数键条目按键从小到大排列后的值（仍为 `ArgExpr`，待步骤 3 处理）。
- **命名剩余收集**：若声明了 `...ys`，则 `ys` 绑定为一个命名空间，包含 `A` 中所有**未被消耗**且非整数键的条目（值仍为 `ArgExpr`，待步骤 3 处理）。
- **未绑定形参**：任何在以上规则后仍未绑定到实参的普通形参，其值必须为 `None`。

若某个 `ArgExpr` 同时被两个形参消耗（例如通过实现错误导致），实现必须报错或坍缩为 `Never`；不得产生未定义行为。

**步骤 3：按 `wrap/directly` 规则实现求值**

对步骤 2 中绑定到 `ArgExpr(E)` 的每个普通形参 `p`：

- 若 `p` 带有 `wrap`，且该 `ArgExpr` 的语法形态不是 `directly { E }`，则该形参的值必须为 Thunk `() { E }`，并且 **E 不得在调用点求值**。
- 否则实现必须对 `E` 求值，并将其结果作为该形参的值。

对 `...[]xs` 与 `...ys` 中的每个 `ArgExpr`，实现必须按同样规则递归处理：若容器中元素最终绑定到 `wrap` 形参则构造 thunk，否则求值。容器本身的构造应保持左到右的实参求值顺序：所有“需要立即求值”的 `E` 必须按其在源代码中出现的顺序求值（展开实参的求值顺序也参与其中）。

##### 语法等价（示例级）

`f{ a, b }` 等价于 `f{ a: a, b: b }`（其中 `a`、`b` 为变量名且同时也是形参名）。

```morf
let add = (x, y) { x + y }
add{ x: 1, y: 2 }
add{ 1, 2 }
```

#### 4.3.3 剩余参数模式

在函数参数定义中，可以使用剩余参数算符 `...` 收集未匹配的参数。详细语法和语义见 **3.3.2 剩余参数语义**。

**快速参考**:

* **位置参数收集**: `(...[]params) { expr }` - 收集所有剩余位置参数为序列
* **命名参数收集**: `(...params) { expr }` - 收集所有剩余命名参数为命名空间
* **混合模式**: `(a, b, ...[]xs, ...ys) { expr }` - 同时使用命名参数和剩余参数

**示例**:
```morf
// 位置参数收集
let sum = (...[]nums) { 
  nums.Reduce{ (a, b) { a + b }, 0 } 
}
sum{ 1, 2, 3, 4 }  // 10

// 命名参数收集
let makeConfig = (name, ...options) { 
  { name, ...options } 
}
makeConfig{ name: "App", debug: true, port: 3000 }
// { name: "App", debug: true, port: 3000 }

// 混合模式
let complex = (first, ...[]rest, ...props) { 
  { first, rest, props } 
}
complex{ 1, 2, 3, x: 10, y: 20 }
// { first: 1, rest: [2, 3], props: { x: 10, y: 20 } }
```

> **注**: 剩余参数模式遵循严格的优先级规则：显式命名参数 > 位置参数顺序匹配 > 位置收集 > 命名收集。一旦参数被绑定，就不能再被重新赋值。

#### 4.3.4 参数类型约束

参数默认类型为 `Uni`（全集），可以使用 `:` 指定类型约束。

* **语法**: `(param: Type) { expr }`
* **语义**: 约束 `param` 必须是 `Type` 的子类型
* **类型检查**: 在调用时，传入的值必须满足类型约束

**示例**:
```morf
// 约束参数为 Number 的子类型
let square = (x: Number) { x * x }

square{ 5 }      // ✓ 合法
square{ "text" } // ✗ 类型错误

// 约束参数为字符串
let greet = (name: String) { "Hello, " + name }

// 多个类型约束
let divide = (a: Number, b: Number) { a / b }

// 使用区间类型约束
let positive_sqrt = (x: Gt<0>) { Sqrt{ x } }
```

#### 4.3.5 参数作为泛型

参数本身就是泛型参数，可以在类型约束中直接引用其他参数。

* **语法**: `(T, value: T) { expr }`
* **语义**: 参数 `T` 作为类型，`value` 被约束为 `T` 的实例
* **应用**: 支持高阶类型编程和泛型函数

> **注**: 由于 Morf 中类型和值是统一的，类型构造器（如 `List`, `Optional`）可以作为参数传递，实现了对高阶类型（HKT）的自然支持。

**示例**:
```morf
// 泛型身份函数
let identity = (T, x: T) { x }

identity{ Number, 42 }    // 返回 42
identity{ String, "Hi" }  // 返回 "Hi"

// 泛型容器构造
let make_pair = (T, a: T, b: T) { [a, b] }

make_pair{ Number, 1, 2 }     // [1, 2]
make_pair{ String, "a", "b" } // ["a", "b"]

// 显式标注泛型返回类型
// 这里的 `-> T` 表示返回值的类型必须是 T 的子类型
// 而不是说函数返回 T 这个类型对象本身
let identity = (T, x: T) -> T { x }

// 高阶类型约束
let apply_twice = (F, x, y: F{x}) { F{ F{ x } } }
// F 是一个函数，y 必须是 F{x} 的子类型

// 复杂泛型示例
let map = (T, U, f: (T) -> U, xs: Seq{T}) {
  // xs 的每个元素是 T，f 将 T 映射到 U
  // 返回 Seq{U}
}
```

**类型构造器参数**:
```morf
// 参数可以是带参数的类型构造器
let wrap_in_list = (x, y: List{x}) { y }
// y 必须是 List{x} 类型

// 约束为某个函数的应用结果
let constrained = (T, F, value: F{T}) { value }
// value 必须是 F{T} 类型
```

### 4.4 返回类型系统

Morf 的函数返回类型模型严格区分“实现推导”与“接口承诺”。这一设计旨在理清“代码实际做了什么”与“API 承诺了什么”之间的关系。

#### 4.4.1 推导返回类型 (Inferred Return)
这是基于函数体控制流与表达式推导出的真实返回类型。

* **定义（返回类型函数）**: 令函数体为 `Body`，系统基于控制流分析（CFA）与流敏感细化，推导出一个**返回类型函数** $R_{inferred}(\vec{P})$。其中 $\vec{P}$ 是形参类型环境（可包含依赖于参数的类型变量），$R_{inferred}$ 的结果允许是**分段/条件类型**，以保留“控制流即类型”的语义。
* **特性**:
    *   **控制流保留**: 若分支条件依赖于形参（或由形参导出的类型谓词）且在编译期不可判定，实现应当把结果保留为条件类型（而不是立即拍扁为 Union）。
    *   **精确性**: 反映了实现的真实行为。
    *   **默认行为**: 若未显式标注返回承诺（见 4.4.2），函数对外暴露的静态签名类型可以直接是 $R_{inferred}$（一个类型函数）。

* **定义（擦除上界）**: 为服务于“仅承诺父类型、不暴露控制流细节”的接口视角，可定义擦除后的上界：
  $$
  R_{erased} \ \triangleq\ \text{Erase}(R_{inferred})
  $$
  其中 `Erase` 表示把条件/分段信息擦除为一个保守的上界（通常对应“所有分支结果的并集”）。该上界适合作为约定返回类型的候选，但不应当被当作推导返回类型本身。

```morf
let f = (x) {
  If { x > 0, 1, "error" }
}
// 推导返回类型：一个依赖于参数 x 的条件类型/类型函数
// 直观等价于 Typescript：
//   x extends Gt<0> ? 1 : "error"
//
// 若把依赖擦除，仅取对外承诺上界（约定返回类型的候选）：
//   1 | "error"
```

#### 4.4.2 约定返回类型 (Contracted Return)
这是开发者在函数签名中通过 `-> Type` 显式标注的类型约束。

* **语法**: `(args) -> Cap { ... }`
* **语义**: 声明该函数的返回值**必须**是 `Cap` 的子类型。这是一种**接口承诺**，屏蔽了实现细节。
* **校验规则**:
    *   **逐次实例化校验**: 对任意一次调用（或一次泛型实例化）得到的实参类型环境 $\sigma$，实现必须验证：
        $$
        R_{inferred}[\sigma] \ <: \ Cap[\sigma]
        $$
        若不满足则报错。
    *   **对外类型视图**: 当存在显式 `Cap` 时，函数对外暴露的签名返回类型应当被视为 `Cap`（实现可以内部保留 $R_{inferred}$ 用于优化/诊断，但调用者只能依赖 `Cap`）。
*   **依赖类型**: `Cap` 表达式可以引用参数列表中的变量，以支持泛型约束。

```morf
// 显式承诺返回 Number (Contract)
// 即使实现推导出的类型是 I32 (Inferred)，对外也只承诺它是 Number
let add = (x, y) -> Number {
  x + y // R_inferred = I32
}
// 校验: I32 <: Number (通过)

// 依赖类型约束
let identity = (T, x: T) -> T { x }
```

#### 4.4.3 协变返回类型
在覆盖（Override）父类方法或实现接口时，函数的承诺返回类型允许协变（Covariant）。即子类方法的 **承诺上界** 可以是父类方法 **承诺上界** 的子类型。

```morf
// 假设 Base.get 的承诺上界是 Number
// 子类 Sub.get 可以承诺返回 Integer (因为 Integer <: Number)
impl Sub for ... {
  get: () -> Integer { ... }
}
```

### 4.5 控制流模式

在 Morf 中，控制流不是通过特殊的语法关键字（如 `if`, `while`）实现的，而是通过**函数**与**自动 Thunk**（`wrap` 参数）的组合来实现的。

这种设计使得用户可以定义自定义的控制流结构，与内置控制流具有同等的地位和语法体验。

#### 4.5.1 条件分支
条件分支通过 `Cond` 或 `If` 函数实现。由于分支代码块被绑定到 `wrap` 参数，它们仅在满足条件时才会被求值。

```morf
// If 是一个普通函数，其定义类似于：
// let If = (cond, wrap thenBranch, wrap elseBranch) { ... }

If { x > 0,
  Log{ "Positive" }, // 只有 x > 0 时才执行
  Log{ "Non-positive" }
}
```

#### 4.5.2 循环与递归
Morf 不提供 `while` 或 `for` 循环关键字。循环通过**尾递归**（Tail Recursion）实现。实现必须对尾调用进行优化（TCO），以保证无限循环不会导致栈溢出。

```morf
let loop = (n) {
  If { n > 0,
    (
      Log{ n },
      loop{ n - 1 } // 尾调用：安全跳转
    ),
    "Done"
  }
}
```

#### 4.5.3 异常与错误处理
Morf 使用 `Result` 类型（`Ok | Err`）或 `Option` 类型（`Some | None`）进行错误处理，配合模式匹配或组合子（Combinators）进行流程控制，而非使用 `try-catch` 机制。

```morf
let result = File.Read{ "data.txt" }

Cond {
  Branch{ result.isOk, Process{ result.value } },
  Else{ Log{ "Error: " + result.error } }
}
```

---

## 5. 数字系统

数字即值。

### 5.1 数值定义

#### 5.1.1 整数字面量

Morf 支持多种进制的整数字面量表示。

*   **十进制**: `123`, `0`, `-42`
*   **二进制**: `0b` 或 `0B` 前缀，如 `0b1010`, `0b1111_0000`
*   **八进制**: `0o` 或 `0O` 前缀，如 `0o755`, `0o123`
*   **十六进制**: `0x` 或 `0X` 前缀，如 `0xFF`, `0x1A2B`

#### 5.1.2 浮点数字面量

浮点数必须包含小数点或指数部分。

*   **小数形式**: `3.14`, `0.1`, `123.0`
*   **科学计数法**: 使用 `e` 或 `E` 表示指数。
    *   `1.2e3` (1200.0)
    *   `1e-4` (0.0001)
    *   `3.14E+2` (314.0)

#### 5.1.3 数值分隔符

为了提高可读性，可以使用下划线 `_` 作为数值分隔符。分隔符可以出现在数字中间的任意位置，但不能出现在开头、结尾或小数点两侧。

*   `1_000_000` (一百万)
*   `0xFF_AA_BB` (十六进制颜色)
*   `3.14159_26535`

#### 5.1.4 语义

*   数字是**具名空间**，每一个数字都有自己独有的名义符号。
*   每一个具体的数字（如 `1` 和 `2`）都是互斥的类型。` 1 & 2 -> Never`。
*   **子类型关系**: 数字之间**不存在**子类型关系。即 $1$ 不是 $2$ 的子类型，反之亦然。即 $1 \not<: 2$。
*   **比较关系**: 数字之间支持比较运算。即 $1 < 2$ 为真。

### 5.2 区分 `<` 与 `<:`

*   **`<` (小于)**: 这是一个比较运算符，返回布尔值。
    *   `1 < 2 -> True`
*   **`<:` (子类型)**: 这是一个类型系统的关系判定。
    *   `1 <: 2 -> False` (因为它们是不同的值)
    *   `1 <: Number -> True`

### 5.3 数字集合体系

为了在类型系统中表达数值范围，Morf 0.2 引入了 **Interval** 体系。

#### 5.3.1 基础区间类型

*   **`Interval`**: 所有区间类型的父接口。
*   **`Lt<N>` (Less Than N)**: 集合 $\{ x \mid x < N \}$。
*   **`Gt<N>` (Greater Than N)**: 集合 $\{ x \mid x > N \}$。

#### 5.3.2 有界区间

替代单一的 `Range`，支持完整的开闭区间组合：

*   **`IntervalOO<Min, Max>`**: Open-Open, $(Min, Max)$, $\{ x \mid Min < x < Max \}$
*   **`IntervalOC<Min, Max>`**: Open-Closed, $(Min, Max]$, $\{ x \mid Min < x \le Max \}$
*   **`IntervalCO<Min, Max>`**: Closed-Open, $[Min, Max)$, $\{ x \mid Min \le x < Max \}$
*   **`IntervalCC<Min, Max>`**: Closed-Closed, $[Min, Max]$, $\{ x \mid Min \le x \le Max \}$

#### 5.3.3 与 Number 的相容性

这些集合类型与具体的数字类型是**相容**的。这意味着一个具体的数字可以是这些集合的子类型。

*   若 $x < N$，则 $x <: \text{Lt}<N>$。
    *   `1 <: Lt<2>` 为 **True**。
    *   `1 & Lt<2> -> 1`。

#### 5.3.4 集合运算

*   `Lt<5> & Lt<3> -> Lt<3>`
*   `Gt<1> & Lt<3> -> IntervalOO<1, 3>`
*   `Lt<1> & Gt<3> -> Never`

## 5.4 具体数字类型体系

### 5.4.1 类型层次结构

Morf 在抽象 `Number` 之下引入一组**具体数字类型根**，用于机器运算与宿主互操作。

#### 类型继承关系（概览）

`Interval ⊇ Number ⊇ (Float | SignedInt | UnsignedInt)`

- **Float**: `F32`, `F64`（IEEE 754）
- **SignedInt**: `I8`, `I16`, `I32`, `I64`
- **UnsignedInt**: `U8`, `U16`, `U32`, `U64`

#### 子类型与互斥

```morf
I32 <: SignedInt <: Number <: Interval
U8  <: UnsignedInt <: Number <: Interval
F64 <: Float <: Number <: Interval

// 不同具体类型之间不存在子类型关系；且视为互斥
I32 ⊄ F64
U8  ⊄ I32
I32 & F64 -> Never
```

**原则**：

1. **无隐式转换**：不同具体类型间不自动转换；混合运算通过“提升”（5.4.4）统一到公共类型。
2. **字面量多态**：数字字面量在约束前属于字面量类型（5.4.2），可按上下文实例化为具体类型。
 
---

### 5.4.2 字面量类型与推断

#### 字面量类型

- **整数**字面量 `n` 的类型为 `IntLit<n>`
- **小数**字面量 `r` 的类型为 `FloatLit<r>`

字面量类型可实例化为兼容的具体数字类型：

- `IntLit<n> <: I8/I16/I32/I64` 当 `n` 落在对应值域内
- `IntLit<n> <: U8/U16/U32/U64` 当 `n` 落在对应值域内
- `IntLit<n> <: Float` 与 `FloatLit<r> <: Float` 总是成立（可能损失精度）

#### 默认推断

- **整数字面量**：无约束时推断为 `I32`
- **浮点字面量**：无约束时推断为 `F64`

#### 字面量后缀（语法糖）

```morf
42i8   // I8
42u32  // U32
3.14f32 // F32
```

---

### 5.4.3 运算符分派（比较 / 算术）

#### 分派原则

**OrdF64 / OrdI32 等：可比较类型的 Trait**

- **同类型**：直接分派到该类型对应的 Impl。
- **混合类型**：先提升到公共类型（5.4.4），再分派。

```morf
// 比较：要求两侧最终为同一具体类型 C，返回 Bool
x < y
// ~>
let C = InferCommonType{ typeof(x), typeof(y) }
Promote.To{ x, C }<OrdC>.Lt{ Promote.To{ y, C } }

// 算术：要求两侧最终为同一具体类型 C，返回 C
a + b
// ~>
let C = InferCommonType{ typeof(a), typeof(b) }
Promote.To{ a, C }<ArithC>.Add{ Promote.To{ b, C } }
```
+> 注：`<`, `>`, `<=`, `>=` 分派到 `OrdC`；`+`, `-`, `*`, `/` 分派到 `ArithC`。

---

### 5.4.4 类型提升

混合类型运算通过“提升”将两侧统一到**公共类型** `C`。

#### 公共类型规则

设 `C = InferCommonType{ T1, T2 }`，要求：

1. `T1` 与 `T2` 都可被提升为 `C`
2. `C` 是满足 (1) 的最小类型（尽量不扩大位宽/不引入浮点）

典型结果（非穷举）：

- `F64` 与任意 `Number`：`C = F64`
- `F32` 与整型：`C = F32`（可能损失精度）
- 有符号与无符号混合：选择能覆盖两者值域的最小有符号类型  
  例如：`I8 + U8 -> I16`，`I32 + U32 -> I64`
- 位宽扩展：`I8 + I16 -> I16`，`U8 + U16 -> U16`

#### 提升算子

```morf
// 标准库提供的提升工具
impl Promote for Number {
  // 将任意 Number 子类型提升到目标类型
  static To{ value: Number, target: Type } -> target {
    Cond {
      Branch{ value <: target, value },  // 已经兼容，无需转换
      Else{ Intrinsic.Convert{ value, target } }  // 宿主环境执行转换
    }
  }
}
```

### 5.4.5 边界检查与溢出行为

#### 整数溢出策略

Morf 的整数运算默认采用**检查溢出（Checked）**模式：

```morf
let x: I8 = 127
let y = x + 1  // 运行时错误：I8 溢出
```

**可选的溢出模式**（通过 Impl 选择）：

1.  **Wrapping**（环绕）：`I8.Wrapping.Add{ 127, 1 } -> -128`
2.  **Saturating**（饱和）：`I8.Saturating.Add{ 127, 1 } -> 127`
3.  **Unchecked**（未检查，用于性能关键路径）：`I8.Unchecked.Add{ 127, 1 }` 行为未定义

#### 浮点特殊值

F64/F32 遵循 IEEE 754 标准，支持：

*   **Infinity**：`F64.Infinity`, `F64.NegInfinity`
*   **NaN**：`F64.NaN`

```morf
1.0 / 0.0  // -> F64.Infinity
0.0 / 0.0  // -> F64.NaN

F64.NaN == F64.NaN  // -> False（遵循 IEEE 754）
```

---

### 5.4.6 类型转换 API

#### 显式转换

```morf
// 标准库提供的转换工具
impl Convert for Number {
  static ToI32{ value: Number } -> (I32 | None) {
    Cond {
      Branch{ value <: IntervalCC{ I32.Min, I32.Max }, 
        Intrinsic.ConvertToI32{ value } 
      },
      Else{ None }  // 超出范围返回 None
    }
  }
  
  static ToF64{ value: Number } -> F64 {
    Intrinsic.ConvertToF64{ value }  // 总是成功，但可能损失精度
  }
  
  // 其他类型的转换方法...
}
```

### 5.4.7 与 Interval 系统的集成

具体数字类型与 Interval 系统无缝集成：

```morf
// 区间约束自动推断具体类型
let positive_i32 = Gt<0> & I32
// 等价于 I32 & IntervalOO<0, I32.Max>

let byte_range = IntervalCC<0, 255> & I32
// 类型检查器知道这个值可以安全转换为 U8

// 在函数签名中使用
let safe_div = (a: I32, b: I32 & ~{0}) -> I32 {
  a / b  // 编译器知道 b 不为 0，可以优化掉除零检查
}
```


---

## 6. 序列系统

Morf 的序列模型构建在命名空间与数字系统之上。Morf 中的序列本质上是**定长**的。通过对 `length` 属性施加不同强度的数值约束，可以定义不同长度范围的序列类型，但其实例在运行时长度始终是固定的。

### 6.1 元组 (Tuple)

元组是 Morf 中最基础的序列结构。

*   **定义**: 包含数值索引属性，且 `length` 属性为 **Number** 的命名空间。
*   **结构示例**:
    ```morf
    let T = [A, B]
    // 展开等价于
    let T = {
      __nominal__: TupleTag,
      length: 2,         // 长度是精确的 2
      0: A,
      1: B
    }
    ```
*   **不变性**:
    *   由于 `2` 和 `3` 是互斥的 (`2 & 3 -> Never`)。
    *   因此 `[A, B]` (len=2) 和 `[A, B, C]` (len=3) 互斥，不存在子类型关系。
    *   **结论**：定长元组天然避免了协变/逆变带来的类型安全问题。

### 6.2 字符串 (String)

字符串在 Morf 中被视为 **原子值**，但对外提供类似只读元组的行为。

#### 6.2.1 定义与类型

*   **原子性**: 字符串是 Unicode 码点（Code Point）的序列。在值层面，它是不可分割的原子实体，不是由更小的对象组合而成的。
*   **类型层次**:
    *   **String**: 所有字符串值的父类型。
    *   **字面量类型**: 每一个具体的字符串字面量（如 `"hello"`）都是一个独立的单例类型。
    *   **互斥性**: 不同的字符串字面量类型是互斥的。`"a" & "b" -> Never`。

#### 6.2.2 虚拟投影

尽管字符串是原子的，但在进行属性访问时，系统将其投影为一个**只读元组**。

*   **Length**: 具有 `length` 属性，值为字符串的字符数（Code Point 数量）。
*   **索引访问**: 支持通过数字索引访问特定位置的字符。
    *   Morf **不区分字符（Char）与字符串**。`s[i]` 的返回值仍然是一个 `String` 类型，其长度为 1。
    *   越界访问返回 `None`。

```morf
let s = "Morf"

// 长度
s.length     // 4

// 索引
s[0]         // "M" (String 类型)
s[99]        // None

// 结构化视角
// "Morf" ≅ {
//   length: 4,
//   0: "M", 1: "o", 2: "r", 3: "f",
//   [...Number]: None
// }
```

#### 6.2.3 字符串拼接

虽然序列不支持变长修改，但可以通过 `+` 运算符连接两个字符串生成新的字符串值（见 3.6 节）。
---


## 7. 递归与不动点

Morf 支持结构化递归，允许定义无限深度的类型结构（如链表、树），但严格区分“结构构造”与“数值/逻辑计算”。

### 7.1 核心原则

1.  **结构递归**: 
    允许。当一个 Namespace 的属性指向自身，或者通过 Union 间接指向自身时，系统视为合法的“无限形状”。
    * *语义*: 它是懒加载的 (Lazy)，只有在访问具体属性时才会展开。
    * *与 None 的交互*: 若递归路径上的某节点计算结果为 `None`，根据 None 的传染性，整个递归访问路径将坍缩为 `None`。
2.  **计算递归**: 
    禁止。在表达式求值（如 `a + b`）或函数逻辑中出现的无终止循环将导致系统坍缩。
    * *语义*: 这种循环在逻辑上等价于无法到达终点，因此求值结果为 `Never`（底空间）。

### 7.2 实现建议：打结法

为了在保持不可变性（Immutability）和驻留（Interning）的前提下支持递归，推荐采用“打结”算法。

#### 7.2.1 占位符与路由
1.  **检测循环**: 在求值 `let A = { ... }` 时，将变量名 `A` 放入当前作用域的 "Pending" 栈。
2.  **创建入口**: 若在构造过程中再次遇到 `A`，不立即递归求值，而是创建一个 **`RecursiveRef` (递归引用)** 节点。该节点仅包含一个指向 `A` 最终地址的“入口”。
3.  **延迟绑定**: `{ next: Ref(A) }` 的 Hash 计算应包含其结构的“形状”而不包含 `Ref(A)` 的具体值，或者使用特殊的循环 Hash 算法。

#### 7.2.2 打结过程
1.  **构造形状**: 完成 Namespace 的初步构造。
2.  **回填**: 在 Interner 池中注册该形状前，将 `RecursiveRef` 内部的指针指向该 Namespace 自身的内存地址。
3.  **化简**: `A & A` 在递归层面上应能识别出它们是同一个“结”，从而避免无限展开。

### 7.3 示例与推导

#### 7.3.1 链表定义
```javascript
// 定义 List 为：要么是 End，要么是 Node 且 next 指向 List
let List = 
  | { kind: "End" },
  | { kind: "Node", next: List } 
```
* **推导**: 系统识别出 `List` 在定义中引用了自身。内部表示为 `End | { Node, next: Ref(List) }`。
* **合法性**: 这是一个合法的结构递归。

#### 7.3.2 别名循环
```javascript
let A = B
let B = A
```
* **结论**: 没有任何构造器（Namespace `{}`）介入。这种纯粹的别名循环导致符号解析死锁，系统无法确定其结构，判定为 **`Never`**。

#### 7.3.3 计算循环
```javascript
let Num = Num - 1
```
* **结论**: 减法运算需要立即求出 `Num` 的数值。由于 `Num` 处于 "Pending" 状态且未被构造器包裹，无法进行数值运算，直接返回 **`Never`**。

---

## 8. 可变状态与引用系统

Morf 引入了 **"一等公民槽位"** 模型。这一设计旨在弥合纯函数式编程（不可变数据）与命令式编程（状态变化）之间的鸿沟，同时避免引入额外的 `Ref` 对象包装器。

### 8.1 核心模型：变量即槽位

*   **`let`**: 创建一个值的直接绑定。在作用域内不可重绑定。
*   **`mut`**: 创建一个可变的 **变量槽**。

当声明 `mut a = 1` 时，编译器在底层构建了一个隐式的命名空间，其逻辑结构类似于：
```morf
// 概念模型，非真实语法
let $slot_a = { value: 1 }
```

### 8.2 自动解引用

为了保证语法的简洁性，Morf 在普通表达式中对 `mut` 变量进行自动拆箱。

*   **读取**: `let b = a + 1`。编译器自动将其转换为 `$slot_a.value + 1`。
*   **取址**: `let r = &a`。使用 `&` 运算符获取 `$slot_a` 本身（见 3.13）。
*   **赋值**: `a = 2`。编译器自动将其转换为 `$slot_a.value = 2`。
*   **快照传递**: 当 `mut` 变量传递给**非 mut** 参数时，传递的是其当前值的快照。

```morf
let LogVal = (v) { Log{v} }

mut x = 1
LogVal(x) // 传递的是 1 (Copy)，而非 x 的槽位
```

### 8.3 引用传递

为了在函数间共享状态（例如异步更新或原地修改），函数参数可以显式标记为 `mut`。这实现了类似于“引用传递”的效果。

*   **语法**: `f: (target: mut Number) { ... }`
*   **语义**: 此时传递的不再是值的快照，而是 **Slot 本身**。
*   **效果**: 函数内部对 `target` 的赋值会直接更新外部的 Slot。

示例：
```morf
let AsyncInc = (target: mut Number) {
  // target 引用了外部的 Slot
  TimeOut(1000, () {
    target += 1 
  })
}

mut a = 1
AsyncInc(a) // a 变为 2
```

### 8.4 结构化更新

由于 Morf 的基础类型是不可变的，对 `mut` 变量的属性更新遵循 **"Copy-on-Write"** 语义的变体。

*   **语法**: `obj.prop = val`
*   **语义**: 等价于 `obj = Update(obj, "prop", val)`。
*   **底层行为**:
    1.  创建一个包含新属性值的新 Namespace。
    2.  将 `mut` 变量槽指向这个新地址。
    3.  利用结构共享优化内存开销。

这确保了即便引入了可变性，每次赋值操作产生的都是一个新的、合法的不可变快照，从而天然支持时间旅行调试。

### 8.5 流敏感分析

为了在结构化类型系统中安全地使用 `mut`，编译器对 `mut` 变量实施 **SSA (Static Single Assignment)** 变换与流敏感分析。

这意味着同一个 `mut` 变量在不同的代码路径下可以拥有不同的、更精确的类型（Type Narrowing）。

```morf
mut x = Number | String  // x 类型宽泛

Cond {
  Type.IsNum{x}, {
    // 在此块中，x 被细化为 Number
    // 编译器允许数学运算
    x += 1 
  },
  Else {
    // 在此块中，x 被细化为 String
    Log{ "String: " + x }
  }
}
```

---

### 9. Effect 传播与坍缩

为了支持编译时展开并保证副作用的可预测性，Morf 0.2 引入了基于污染追踪的 Effect 系统。

#### 9.1 核心定义

*   **Effect**: 一个名义符号，表示某种非纯粹的计算行为。
*   **Effect 集合 ($\epsilon$)**: 一个表达式在求值过程中可能触发的所有 Effect 的并集。
*   **固有效应 (`intrinsic_effect`)**: 对任意可调用值 `f`，`f.intrinsic_effect` 是“一次调用 `f{...}` 在其函数体内部可能触发的 Effect 集合”。  
    *   **用户函数**：若 `let f = (...) { E }`，则定义 `ε(f) = None`，且 `f.intrinsic_effect = ε(E)`。  
    *   **宿主 primitive**：其 `intrinsic_effect` 由宿主环境在定义处显式标注（例如 `Sys.IO.Write` 具有 `Effect.IO`）。
*   **纯粹性 (Purity)**: 若 $\epsilon(E) = \text{None}$，则称表达式 $E$ 是纯的。


#### 9.2 Effect 的源头

系统中存在两类原子级的 Effect 源头：

1.  **状态源**:
    *   对任何 `mut` 槽位的读取（Read）或写入（Write）操作，自动被赋予 `Effect.State`。
    *   *注：若分析器能证明 `mut` 变量未逃逸出当前闭合块且不影响外部环境，可进行纯化优化。*
2.  **原生源**:
    *   由宿主环境提供的 primitive 函数（如 `Sys.IO.Write`, `Sys.Time.Now`）带有特定的名义 Effect（如 `Effect.IO`）。

#### 9.3 传播规则

Effect 遵循“向上污染”的代数并集规则：

1.  **复合表达式**: $\epsilon(f\{a, b, \dots\}) = \epsilon(f) \cup \epsilon(a) \cup \epsilon(b) \dots \cup f.\text{intrinsic\_effect}$。
2.  **属性访问**: $\epsilon(obj.prop) = \epsilon(obj)$。
3.  **集合/元组构造**: $\epsilon([a, b]) = \epsilon(a) \cup \epsilon(b)$。构造本身是纯的，但其成员的求值可能带有 Effect。

这意味着如果 `List.Map` 的回调函数 `f` 带有 `IO` Effect，那么 `List.Map{list, f}` 整个表达式的 Effect 集合也将包含 `IO`。

#### 9.4 封印与坍缩

为了在含有副作用的系统中保留纯粹的片段，Morf 使用函数抽象和 `wrap` 来隔离 Effect。

1.  **函数定义 (Abstraction)**: 
    *   定义一个函数 `let F = () { E }` 是纯的操作。$\epsilon(F) = \text{None}$。
    *   内部的 Effect $\epsilon(E)$ 被“封印”在函数体中。
2.  **自动 Thunk (Wrap)**:
    *   `wrap { E }` 将表达式 $E$ 的 Effect 坍缩。`wrap` 表达式本身的结果是一个纯的 Namespace（一个零参函数）。
3.  **解封 (Apply)**:
    *   当表达式发生调用（Apply）时，被封印的 Effect 释放并向上污染。对调用表达式 `f{a, b, ...}`，其 Effect 定义为：
        $$ \epsilon(f\{a,b,\dots\}) = \epsilon(f)\ \cup\ \epsilon(a)\ \cup\ \epsilon(b)\ \cup\ \dots\ \cup\ f.\text{intrinsic\_effect} $$
    *   特别地，若 `wrap { E }` 产生一个零参 thunk `t`，则 `t{}` 的 Effect 恰为 `t.intrinsic_effect`（并按上式传播到调用点）。

#### 9.5 编译展开准则

编译器根据 Effect 集合决定优化策略：

1.  **完全展开**: 若 $\epsilon(E) = \text{None}$ 且所有依赖项为常量，则进行常量折叠。
2.  **部分展开**:
    *   对于 Namespace $\{ a: E_1, b: E_2 \}$，若 $E_1$ 是纯的而 $E_2$ 是有副作用的。
    *   编译器可以安全地预计算并将 `obj.a` 替换为结果值。
    *   `obj.b` 必须保留为原始调用，或仅在确定执行顺序的前提下进行展开。
3.  **副作用隔离**: 编译器禁止跨越有 Effect 的表达式进行指令重排，除非能证明两个 Effect 集合是正交的（Orthogonal）。

**正交 (Orthogonal) 的最小定义（保守）**：
- 称两个表达式 `A` 与 `B` 的 Effect 集合正交，当且仅当：$$ \epsilon(A) \cap \epsilon(B) = None $$ 且 `Effect.State ∉ (ε(A) ∪ ε(B))`。
- 实现据此可安全地在不改变可观测行为的前提下，对 `A` 与 `B` 进行重排；该定义是保守近似，未来可通过更精细的 Effect（如区分 Read/Write）放宽。

---

## 10. Impl 系统

Morf 中的 “方法”，是由 **Impl 命名空间** 提供的一组函数定义，并通过统一的 **点号 (`.`)** 语法，在表达式层面被脱糖与分派。

本章规范定义：

- `impl` 声明会产生什么命名空间结构；
- `.` 符号的统一查找规则（Data > Impl）；
- `<impl_id>.` 的显式指定规则；
- `extends`/`super` 的覆盖与继承规则；
- 当存在多个候选实现时的选择规则（later-wins）。

### 10.1 Impl 也是命名空间

#### 10.1.1 Impl 的声明形式

`impl` 用于声明一个实现命名空间，其内部包含若干“方法条目”（键为方法名，值为函数）。

```morf
impl TreeImpls for (Tree | None) {
  Invert: (self) { ... }
}
```

该声明的**规范性含义**是：构造一个命名空间 `TreeImpls`，并将其标记为“一个 impl”，且该 impl 与某个**目标类型**（此处为 `Tree | None`）关联。

#### 10.1.2 Impl 的名义标记
为了使“这是一个 impl”这一事实可被系统可靠识别，impl 命名空间必须携带名义标记。其可以这样表示：

```morf
AnotherImpls
// { [NominalKey]: DiSet{ ImplNominal, AnotherImplsNominal }, foo: ... }
```

因此本规范约束：

- 任意 `impl X ...` 产生的命名空间 `X`，其 `[NominalKey]` 必须包含 `ImplNominal`。
- 同时 `[NominalKey]` 必须包含一个该 impl 自身的名义符号（如 `AnotherImplsNominal`），用于稳定标识该实现体。

> 注：这里的“包含”使用集合语义（`DiSet{...}`）表达；具体存储形式由实现决定，但必须可判定等价。

#### 10.1.3 方法修饰符：static

在 impl 内部定义方法时，可以使用 `static` 关键字进行修饰：

- **普通方法 (Ordinary Method)**：默认状态。期望在调用时接收“调用者（Subject）”作为第一个参数（即 `self`）。
- **静态方法 (Static Method)**：使用 `static` 修饰。在调用时**不接收**调用者，仅利用 Impl 机制进行上下文查找。

---

### 10.2 `impl ... for T`：目标类型与适用性

`impl X for T { ... }` 中的 `T` 被称为该 impl 的 **目标类型**。

给定某个 `self` 值/类型 `S`，称 `X` 对 `S` **适用**，当且仅当：

- $ S <: T $

（即 `self` 的类型是 `T` 的子类型。）

示例：

```morf
impl TreeImpls for (Tree | None) { ... }
```

则 `TreeImpls` 对 `Tree` 与 `None` 均适用。

---

### 10.3 统一调用语法 (.) 与查找范围

#### 10.3.1 统一访问规则

表达式 `E.Key` 的解析遵循 **"Data 优先，Impl 兜底"** 的原则。

查找步骤如下：

1.  **Data 查找**:
    *   检查 `E` 本身是否拥有名为 `Key` 的属性。
    *   若存在 -> 返回 `E[Key]` (直接属性访问)。
    *   **优先级**: 数据的 Key 永远高于 impl 的方法名称。这意味着如果数据中存在与方法同名的属性，方法将被“遮蔽”。

2.  **Impl 查找 (Contextual Lookup)**:
    *   若 Data 查找失败，则在 **适用 Impl 候选集** 中查找名为 `Key` 的方法。
    *   若命中实现 `I` 中的方法 `M` -> 根据 `M` 的修饰符进行脱糖调用（见 10.3.3）。
    *   若未命中 -> 返回 `None` (或报错，视具体语境)。

#### 10.3.2 Impl 候选集合

Impl 查找 **仅允许**在以下候选集合中进行：

1. **`impl for 具名空间`**：目标类型为某个具名空间的 impl；
2. **`impl for DiSet{ 具名空间, None }`**：目标类型为 `DiSet{N, None}`（即 `N | None`）这一类形态的 impl；
3. **`impl` 命名空间自身**：即候选必须是带有 `ImplNominal` 标记的命名空间。

超出以上范围的 `impl`（例如纯结构目标类型 `for { value: Uni }`）**不得**被 `.` 直接自动命中；必须使用 `<impl_id>.` 显式指定（见 10.4）。

> 直观上：隐式查找只服务于“以具名空间为中心的 impl 体系”，避免结构匹配导致的开放世界歧义与不可预期分派。

#### 10.3.3 Impl 命中的脱糖语义

若 `E.Method{ args }` 通过 Impl 查找命中实现 `X`，则采取以下脱糖规则：

1.  **普通方法**：
    *   脱糖为：`X.Method{ E, args }`
    *   语义：`E` 被作为第一个位置参数（`self`）注入。这是最常见的“实例方法”行为。

2.  **静态方法** (`static`)：
    *   脱糖为：`X.Method{ args }`
    *   语义：`E` 仅作为**寻址锚点**（用于在上下文查找中命中实现 `X`），随后**被丢弃**，不参与参数传递。

---

### 10.4 `<impl_id>.` 与 `<impl_id>[]`：显式指定实现

当满足下列任一条件时，必须使用显式形式：

- 发生了名称冲突（Data 遮蔽了 Method），需要强制调用 Method；
- 候选范围内找不到适用实现；
- 存在你希望使用但不在允许范围内的实现（例如纯结构目标类型的 impl）；
- 或者你希望绕过默认选择规则，强制指定某个实现体。

#### 10.4.1 显式调用语法

* **点号形式**: `E<ImplId>.Method{ args }`
* **方括号形式**: `E<ImplId>[keyExpr]{ args }`

**规范性脱糖**：

两种形式都脱糖为相同的语义：
- `ImplId.Method{ E, args }` 或 `ImplId[keyExpr]{ E, args }`

#### 10.4.2 点号形式示例

```morf
impl AnotherImpls for { value: Uni } {
  foo: (self) { self.value }
}

let t = { value: 1, foo: "data" }

// 1. t.foo -> "data" (Data 优先)
// 2. Impl for 结构类型不能被直接命中

// 使用显式语法调用 Impl
t<AnotherImpls>.foo{} // 1
// 等价于
AnotherImpls.foo{ t } // 1
```

#### 10.4.3 方括号形式示例

方括号形式适用于动态方法名或非标识符键。

```morf
impl StringOps for String {
  reverse: (self) { ... }
}

let s = "hello"
let methodName = "reverse"

// 方括号形式：动态方法名
s<StringOps>[methodName]{}       // 使用 StringOps.reverse
s<StringOps>.reverse{}           // 等价，但方法名是静态的
```

---

### 10.5 `extends` 与覆盖

#### 10.5.1 Impl 继承

`impl Child extends Parent { ... }` 声明 `Child` 继承 `Parent` 的方法集合，并允许对同名条目进行覆盖。

```morf
impl HyperTreeImpls extends TreeImpls {
  Invert: (self) { ... }
}
```

#### 10.5.2 覆盖规则

在同一条方法名 `Method` 上，如果 `Child` 与 `Parent` 均提供实现，则 `Child.Method` 覆盖 `Parent.Method`。

由于 Morf 中“数据就是类型”，因此 impl 本身也处于类型关系与命名空间结构之中；**签名一致**的覆盖是合法的语言行为。

#### 10.5.3 `super` 语义

在 `Child` 的方法体内部，`super.Method{ ... }` 表示调用被覆盖的父级实现（按继承链向上解析到最近的一个定义点）。

示例：

```morf
impl HyperTreeImpls extends TreeImpls {
  Invert: (self) {
    Console.log("HyperTreeImpls.Invert")
    super.Invert{}
  }
}
```

---

### 10.6 同名方法的选择规则（默认分派）

当表达式 `E.Method{...}` 在允许的候选范围内存在多个“适用实现”时，本规范采用以下选择规则：

- **later-wins（后来者优先）**：若同时存在多个 impl 都定义了 `Method`，则选择“后出现/后生效”的实现体。

该规则与示例断言一致：

```morf
// 如果同时有两个 impl 都定义了 Invert，那么应该使用后来者的实现
let inv = t.Invert{}
```

> 注：何谓“后出现/后生效”由实现的可观测机制定义（例如：同一作用域内的声明顺序、模块加载顺序、或显式导入顺序）。但实现必须保证：给定同一程序与同一加载顺序，分派结果是确定的。

---

## 11. 标准库

Morf 标准库采用 **“类型根 + 后台实现”** 的组织范式：

- **类型根 `X`**：一个具名空间，作为该概念的父类型入口。
- **实现 `XxxImpl`**：一个或多个 `impl` 命名空间，为类型根提供方法与工具函数。


### 11.1 核心全集
定义在全局作用域的基元。

*   **Uni**: `{}`。全集，所有类型的父类型。
*   **None**: 递归的空值。
*   **Proof**: `~None`。实存值。
*   **Never**: 逻辑矛盾。

### 11.2 流程控制
*   **Cond{ ...branches }**
*   **Branch{ cond, wrap do }**
*   **Else{ wrap do }**
*   **If{ cond, wrap then, wrap else }**

### 11.3 数字模块
*   **Interval**: (类型根) 所有区间的父类型。
*   **impl IntervalImpl for Interval**: (工具集)
    *   **static Lt{ n }**:返回类型 `Lt<n>`。
    *   **static Gt{ n }**:返回类型 `Gt<n>`。
    *   **static OO{ min, max }**: 返回 $(min, max)$。
    *   **static OC{ min, max }**: 返回 $(min, max]$。
    *   **static CO{ min, max }**: 返回 $[min, max)$。
    *   **static CC{ min, max }**: 返回 $[min, max]$。

*   **Number**: 所有数值的父类型。其父类型是 `Interval`。

### 11.4 序列模块
* **Seq**: 所有序列（Tuple / String 投影等）的父类型。
* **impl SeqImpl for Seq**:
  * **static Of{ ...items }: Seq**: 构造序列。
  * **Head{}**: 取首元素。
  * **Tail{}**: 取剩余部分。
  * **Map{ f }**: 投影。
  * **Filter{ pred }**:过滤。

### 11.5 符号和名义
* **Symbol**: 所有符号的父类型。
* **impl SymbolImpl for Symbol**:
  * **Create{}: Symbol**: 创建一个符号。 

* **Nominal**: 名义系统的入口命名空间。
* **impl NominalImpl for Nominal**:
  * **Create{ ...[]parents: NominalSet }: NominalSet**: 创建一个新的名义符号；若提供 `parents`，新符号在子类型系统中是 `parents` 的子类型（见 3.3）。
  * **CreateNs{ ...[]parents: NamedNamespace, ...keys: Namespace }: Namespace**: 创建一个新的具名空间作为“类型根”，并注入其 `[NominalKey]` 身份（可选继承 `parents`）。

### 11.6 基础逻辑

* **Bool**: 布尔父类型。`True | False`（规范化为 `DiSet{ True, False }`）
  * **True**: `Bool` 的子单例，表示真。
  * **False**: `Bool` 的子单例，表示假。

* **Assert**: 断言工具入口。
* **impl AssertImpl for Assert**: (工具集)
  * **Eq{ a, b }**: 强相等性检查，不相等则返回 `Never` 或触发宿主异常。

## 附录
### 示例代码
#### 二叉树反转
```morf
let Tree = Nominal.CreateNs {
  val: Number,
  left: Tree,
  right: Tree
}

impl TreeOps for (Tree | None) {
  Invert: (self) {
    Cond {
      Branch{ self == None, None },
      Else {
        Tree {
          self.val,
          self.right.Invert{},
          self.left.Invert{}
        }
      }
    }
  }
}

let myTree = Tree { 1, None, Tree { 2, None, None } }
let invertedTree = myTree.Invert{}
```

#### 数据库 Schema
```
// DB 命名空间作为工具集
let DB = Nominal.CreateNs {}

impl DBImpl for DB {
  Int: (width) { 
    { 
      __kind__: "Column", 
      type: "INT", 
      width: width,
      nullable: False
    } 
  }

  Varchar: (len) {
    { 
      __kind__: "Column",
      type: "VARCHAR", 
      length: len,
      nullable: False
    }
  }

  Text: {
    { 
      __kind__: "Column",
      type: "TEXT",
      nullable: False
    }
  }

  // --- 约束/修饰符 (Trait) ---
  // 这些是用来与基础类型做 Intersection (&) 的片段
  
  // 主键标记
  PK: { primary_key: True }
  
  // 自增标记
  AI: { auto_increment: True }
  
  // 可空标记 (覆盖默认值)
  Null: { nullable: True }
  
  // 外键生成器
  FK: (target) {
    { foreign_key: target }
  }
}

// 引入词汇
let { Int, Varchar, Text, PK, AI, FK, Null } = DB

// 定义 Users 表结构
let UserSchema = {
  // 1. 组合：是 Int64, 且是 PK, 且是 AI
  // 结果：{ type: "INT", width: 64, primary_key: True, auto_increment: True, ... }
  id: Int{64} & PK & AI,

  // 2. 普通字段
  username: Varchar{50},
  
  // 3. 可空字段
  email: Varchar{100} & Null,
  
  // 4. 带默认值的逻辑 (可以用 Block 里的逻辑处理，或者扩展 DSL)
  created_at: Int{64} // 存时间戳
}

// 定义 Posts 表结构
let PostSchema = {
  id: Int{64} & PK & AI,
  
  title: Varchar{200},
  content: Text,
  
  // 5. 外键关联
  // 这里的 UserSchema.id 是引用，体现了结构化类型的优势
  author_id: Int{64} & FK{ UserSchema.id }
}
```

#### 查询构建器
```
// --- 1. 基础设施 (Infrastructure) ---

// 定义 Query 为一个名义类型根
let Query = Nominal.CreateNs {
  table: String,
  fields: List,
  conditions: List,
  limit: Interval // 限制只能是数字或 None
}

// 模拟 SQL 操作符的结构表达
// 在 Morf 里，Gt{18} 本身就是一个合法的 Interval 类型/值
let Op = Nominal.CreateNs {}
impl OpImpl for Op {
  // 将结构化条件转为 SQL 字符串
  Format: (val) {
    Cond {
      // 利用模式匹配识别 Interval 类型
      Branch{ val <: Interval.Gt, "> " + val.min },
      Branch{ val <: Interval.Lt, "< " + val.max },
      // 默认为相等
      Else  { "= '" + val + "'" } 
    }
  }
}

// --- 2. Query 实现 (The Builder) ---

impl QueryBuilder for Query {
  
  // 核心：Where 不是修改 this，而是返回一个新的 Intersection
  // 这里的 condition 是一个对象，如 { age: Gt{18} }
  Where: (self, condition) {
    // 结构更新：保留原属性，追加新条件
    Query & {
      ...self,
      conditions: self.conditions.Push{ condition }
    }
  }

  // 字段选择
  Select: (self, ...cols) {
    Query & {
      ...self,
      fields: self.fields.Concat{ cols }
    }
  }

  Limit: (self, n) {
    Query & { ...self, limit: n }
  }

  // 终结操作：生成 SQL
  ToSql: (self) {
    let base = "SELECT " + self.fields.Join{", "} + " FROM " + self.table
    
    let whereClause = Cond {
      Branch{ self.conditions.length == 0, "" },
      Else {
        " WHERE " + self.conditions.Map{ (cond) {
           // 将 { age: Gt{18} } 转换为 "age > 18"
           cond.Entries{}.Map{ (kv) {
             kv.key + " " + Op.Format{ kv.value }
           }}.Join{ " AND " }
        }}.Join{ " AND " }
      }
    }
    
    let limitClause = Cond{
      Branch{ self.limit != None, " LIMIT " + self.limit },
      Else{ "" }
    }

    base + whereClause + limitClause
  }
}

// --- 3. 定义表结构 (Table Definition) ---

let UserTable = Nominal.CreateNs {
  __table_name__: "users"
}

// 扩展 Table 的能力，让它能充当查询起点
impl TableStart for UserTable {
  Find: () {
    Query & {
      table: self.__table_name__,
      fields: List.Of{ "*" }, // 默认查所有
      conditions: List.Of{},
      limit: None
    }
  }
}

// --- 4. 业务实战：组合式查询 (The Magic) ---

// 基础查询
let baseQuery = UserTable.Find{}.Select{ "id", "email", "role" }

// 定义一个“可复用的查询片段” (Query Scope)
// 这是一个普通的 Namespace，不是函数！
let ActiveUserFilter = { 
  conditions: List.Of{ 
    { status: "active", deleted_at: None } 
  }
}

let AdultFilter = {
  conditions: List.Of{
    { age: Interval.Gt{18} }
  }
}

// === 见证奇迹的时刻 ===

// 直接利用 Namespace 的合并特性。
// 我们把 Query 当作数据，把 Filter 当作补丁，直接 "&" 在一起！
let q2 = baseQuery & ActiveUserFilter & AdultFilter

// 此时 q2 的结构自动合并了：
// {
//   table: "users",
//   fields: ["id", "email", "role"],
//   conditions: [
//     { status: "active", deleted_at: None },
//     { age: Gt{18} }
//   ]
// }

Log{ q2.ToSql{} }
// 输出: 
// SELECT id, email, role FROM users 
// WHERE status = 'active' AND deleted_at = NULL 
// AND age > 18
```

#### 订单处理
```
// --- 1. 定义状态 (States) ---
// 每一个状态都是一种“类型”，而不仅仅是一个字符串字段
let Order = Nominal.CreateNs {}

let Pending = Order & { status: "Pending", unpaidAmount: Number }
let Paid    = Order & { status: "Paid",    paidAt: Number, paymentId: String }
let Shipped = Order & { status: "Shipped", trackingNo: String }
let Closed  = Order & { status: "Closed",  reason: String }

// 订单的全集是所有可能状态的 Union
// 在 Morf 里，Pending 和 Paid 是互斥的 (因为 status 字符串不同)
let AnyOrder = Pending | Paid | Shipped | Closed

// --- 2. 定义流转规则 (Transitions) ---

// [规则 1]: 只有 Pending 状态的订单才能支付
impl PayFlow for Pending {
  Pay: (self, pId) {
    // 支付成功，状态跃迁：Pending -> Paid
    Paid { 
      ...self,       // 继承原订单信息
      status: "Paid", 
      paidAt: Sys.Time.Now{},
      paymentId: pId
    }
  }
  
  // 只有未支付的订单才能取消
  Cancel: (self) {
    Closed { ...self, status: "Closed", reason: "User Cancelled" }
  }
}

// [规则 2]: 只有 Paid 状态的订单才能发货
impl ShipFlow for Paid {
  Ship: (self, trackNo) {
    Shipped { 
      ...self, 
      status: "Shipped", 
      trackingNo: trackNo 
    }
  }
  
  // 已支付订单退款后关闭
  Refund: (self) {
    Closed { ...self, status: "Closed", reason: "Refunded" }
  }
}

// [规则 3]: 只有 Shipped 状态才能查看物流
impl TrackFlow for Shipped {
  ShowTrace: (self) {
    Log{ "Tracking: " + self.trackingNo }
  }
}

// --- 3. 业务代码体验 ---

let handleOrder = (o: AnyOrder) {
  // 此时 o 是 Union 类型
  // o.Pay{}  <-- ❌ 编译错误！因为 Shipped/Closed 状态没有 Pay 方法
  // o.Ship{} <-- ❌ 编译错误！
  
  // 你被“强迫”先理清业务状态
  Cond {
    Branch { o.status == "Pending", 
      o.Pay{ "WeChat_12345" }.Ship{ "SF_001" }
    },
    Branch { o.status == "Shipped",
      o.ShowTrace{}  // ✅ 只有这里能看物流
      // o.Cancel{}  // ❌ 根本点不出来！已发货不能直接 Cancel，必须走售后流程
    },
    Else { Log{ "Order is finalized." } }
  }
}
```

#### UI 组件系统与声明式界面

```morf
// VNode：虚拟 DOM 节点
let VNode = Nominal.CreateNs {
  tag: String,              // 元素标签或组件名
  props: Uni,               // 属性对象
  children: Seq             // 子节点序列
}

// Component：组件类型
// 组件是一个接收 props 并返回 VNode 的函数
let Component = (props: Uni) -> VNode

// 创建基础 HTML 元素的工厂函数
let createElement = (tag: String) {
  // 返回一个接收混合参数的函数
  (...[]posArgs, ...namedProps) {
    VNode {
      tag,
      props: namedProps,
      children: posArgs
    }
  }
}

// 1. 定义基础元素构造器
let div = createElement{"div"}
let h1 = createElement{"h1"}
let button = createElement{"button"}

// 2. 定义计数器组件
let Counter = (count, onIncrement) {
  div {
    class: "counter-container"
    
    h1 { "Count is: " + count }
    
    button {
      class: "primary-btn"
      onClick: onIncrement
      "Click Me (+1)"
    }
  }
}

// 3. 调用组件
let vnode = Counter {
  count: 5
  onIncrement: () { console.log{"Clicked!"} }
}
```