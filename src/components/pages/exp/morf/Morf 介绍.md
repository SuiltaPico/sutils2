# Morf 的目标
## 统一概念
| 传统二元对立 | Morf 的统一方式 |
|-------------|----------------|
| **值 vs 类型** | 集合论统一：类型即集合，值也即集合 |
| **类之间的差异** | 集合论统一：类不兼容只是因为名义符号集不兼容 |
| **枚举 vs 接口** | 代数统一：数据叠加身份(Enum) 与 数据叠加行为(Impl) |
| **属性 vs 方法** | 访问统一：行为是上下文对数据的延迟绑定 |
| **控制流 vs 函数** | 求值统一：控制流即惰性求值的普通函数 |
| **异常 vs 返回值** | 效应统一：错误是控制流的一种代数效应 |


## 还原论设计
拒绝特性的堆砌，追求公理的完备。
- 公理化基元：不发明新语法，只发现新公理。整个语言建立在 **Morph (构体)**、**Mixin (叠加)** 和 **Set (集合运算)** 三个基石之上。
- **正交性**：特性之间天然解耦。OOP 的继承不再破坏 FP 的推导，因为它们在底层是同构的。
- **无特权**：用户定义的控制流（如 `Retry`）、数据结构与语言内置（如 `If`）具有同等地位。

## 极低认知噪音
- 语言整洁: 编写时只需考虑纯粹的业务逻辑
- 概念纯净: 万物皆构体，用户不用和语言的语法、概念做斗争。
- **JSON 般纯粹**：编写代码即描述数据。开发者只需关注“业务逻辑是什么”，而非“怎么适配语言特性”。
